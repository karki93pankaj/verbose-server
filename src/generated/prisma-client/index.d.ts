// Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  alertBox: (where?: AlertBoxWhereInput) => Promise<boolean>;
  block: (where?: BlockWhereInput) => Promise<boolean>;
  box: (where?: BoxWhereInput) => Promise<boolean>;
  cons: (where?: ConsWhereInput) => Promise<boolean>;
  faq: (where?: FaqWhereInput) => Promise<boolean>;
  faqCategory: (where?: FaqCategoryWhereInput) => Promise<boolean>;
  grid: (where?: GridWhereInput) => Promise<boolean>;
  gridItem: (where?: GridItemWhereInput) => Promise<boolean>;
  media: (where?: MediaWhereInput) => Promise<boolean>;
  page: (where?: PageWhereInput) => Promise<boolean>;
  pageFaq: (where?: PageFaqWhereInput) => Promise<boolean>;
  pageFaqAccordion: (where?: PageFaqAccordionWhereInput) => Promise<boolean>;
  pros: (where?: ProsWhereInput) => Promise<boolean>;
  prosAndCons: (where?: ProsAndConsWhereInput) => Promise<boolean>;
  quickTip: (where?: QuickTipWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  alertBox: (where: AlertBoxWhereUniqueInput) => AlertBoxPromise;
  alertBoxes: (args?: {
    where?: AlertBoxWhereInput;
    orderBy?: AlertBoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AlertBox>;
  alertBoxesConnection: (args?: {
    where?: AlertBoxWhereInput;
    orderBy?: AlertBoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AlertBoxConnectionPromise;
  block: (where: BlockWhereUniqueInput) => BlockPromise;
  blocks: (args?: {
    where?: BlockWhereInput;
    orderBy?: BlockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Block>;
  blocksConnection: (args?: {
    where?: BlockWhereInput;
    orderBy?: BlockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BlockConnectionPromise;
  box: (where: BoxWhereUniqueInput) => BoxPromise;
  boxes: (args?: {
    where?: BoxWhereInput;
    orderBy?: BoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Box>;
  boxesConnection: (args?: {
    where?: BoxWhereInput;
    orderBy?: BoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BoxConnectionPromise;
  cons: (where: ConsWhereUniqueInput) => ConsPromise;
  conses: (args?: {
    where?: ConsWhereInput;
    orderBy?: ConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Cons>;
  consesConnection: (args?: {
    where?: ConsWhereInput;
    orderBy?: ConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ConsConnectionPromise;
  faq: (where: FaqWhereUniqueInput) => FaqPromise;
  faqs: (args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Faq>;
  faqsConnection: (args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FaqConnectionPromise;
  faqCategory: (where: FaqCategoryWhereUniqueInput) => FaqCategoryPromise;
  faqCategories: (args?: {
    where?: FaqCategoryWhereInput;
    orderBy?: FaqCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FaqCategory>;
  faqCategoriesConnection: (args?: {
    where?: FaqCategoryWhereInput;
    orderBy?: FaqCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FaqCategoryConnectionPromise;
  grid: (where: GridWhereUniqueInput) => GridPromise;
  grids: (args?: {
    where?: GridWhereInput;
    orderBy?: GridOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Grid>;
  gridsConnection: (args?: {
    where?: GridWhereInput;
    orderBy?: GridOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GridConnectionPromise;
  gridItem: (where: GridItemWhereUniqueInput) => GridItemPromise;
  gridItems: (args?: {
    where?: GridItemWhereInput;
    orderBy?: GridItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GridItem>;
  gridItemsConnection: (args?: {
    where?: GridItemWhereInput;
    orderBy?: GridItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GridItemConnectionPromise;
  media: (where: MediaWhereUniqueInput) => MediaPromise;
  medias: (args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Media>;
  mediasConnection: (args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MediaConnectionPromise;
  page: (where: PageWhereUniqueInput) => PagePromise;
  pages: (args?: {
    where?: PageWhereInput;
    orderBy?: PageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Page>;
  pagesConnection: (args?: {
    where?: PageWhereInput;
    orderBy?: PageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PageConnectionPromise;
  pageFaq: (where: PageFaqWhereUniqueInput) => PageFaqPromise;
  pageFaqs: (args?: {
    where?: PageFaqWhereInput;
    orderBy?: PageFaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PageFaq>;
  pageFaqsConnection: (args?: {
    where?: PageFaqWhereInput;
    orderBy?: PageFaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PageFaqConnectionPromise;
  pageFaqAccordion: (
    where: PageFaqAccordionWhereUniqueInput
  ) => PageFaqAccordionPromise;
  pageFaqAccordions: (args?: {
    where?: PageFaqAccordionWhereInput;
    orderBy?: PageFaqAccordionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PageFaqAccordion>;
  pageFaqAccordionsConnection: (args?: {
    where?: PageFaqAccordionWhereInput;
    orderBy?: PageFaqAccordionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PageFaqAccordionConnectionPromise;
  pros: (where: ProsWhereUniqueInput) => ProsPromise;
  proses: (args?: {
    where?: ProsWhereInput;
    orderBy?: ProsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Pros>;
  prosesConnection: (args?: {
    where?: ProsWhereInput;
    orderBy?: ProsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProsConnectionPromise;
  prosAndCons: (where: ProsAndConsWhereUniqueInput) => ProsAndConsPromise;
  prosAndConses: (args?: {
    where?: ProsAndConsWhereInput;
    orderBy?: ProsAndConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProsAndCons>;
  prosAndConsesConnection: (args?: {
    where?: ProsAndConsWhereInput;
    orderBy?: ProsAndConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProsAndConsConnectionPromise;
  quickTip: (where: QuickTipWhereUniqueInput) => QuickTipPromise;
  quickTips: (args?: {
    where?: QuickTipWhereInput;
    orderBy?: QuickTipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuickTip>;
  quickTipsConnection: (args?: {
    where?: QuickTipWhereInput;
    orderBy?: QuickTipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuickTipConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAlertBox: (data: AlertBoxCreateInput) => AlertBoxPromise;
  updateAlertBox: (args: {
    data: AlertBoxUpdateInput;
    where: AlertBoxWhereUniqueInput;
  }) => AlertBoxPromise;
  updateManyAlertBoxes: (args: {
    data: AlertBoxUpdateManyMutationInput;
    where?: AlertBoxWhereInput;
  }) => BatchPayloadPromise;
  upsertAlertBox: (args: {
    where: AlertBoxWhereUniqueInput;
    create: AlertBoxCreateInput;
    update: AlertBoxUpdateInput;
  }) => AlertBoxPromise;
  deleteAlertBox: (where: AlertBoxWhereUniqueInput) => AlertBoxPromise;
  deleteManyAlertBoxes: (where?: AlertBoxWhereInput) => BatchPayloadPromise;
  createBlock: (data: BlockCreateInput) => BlockPromise;
  updateBlock: (args: {
    data: BlockUpdateInput;
    where: BlockWhereUniqueInput;
  }) => BlockPromise;
  updateManyBlocks: (args: {
    data: BlockUpdateManyMutationInput;
    where?: BlockWhereInput;
  }) => BatchPayloadPromise;
  upsertBlock: (args: {
    where: BlockWhereUniqueInput;
    create: BlockCreateInput;
    update: BlockUpdateInput;
  }) => BlockPromise;
  deleteBlock: (where: BlockWhereUniqueInput) => BlockPromise;
  deleteManyBlocks: (where?: BlockWhereInput) => BatchPayloadPromise;
  createBox: (data: BoxCreateInput) => BoxPromise;
  updateBox: (args: {
    data: BoxUpdateInput;
    where: BoxWhereUniqueInput;
  }) => BoxPromise;
  updateManyBoxes: (args: {
    data: BoxUpdateManyMutationInput;
    where?: BoxWhereInput;
  }) => BatchPayloadPromise;
  upsertBox: (args: {
    where: BoxWhereUniqueInput;
    create: BoxCreateInput;
    update: BoxUpdateInput;
  }) => BoxPromise;
  deleteBox: (where: BoxWhereUniqueInput) => BoxPromise;
  deleteManyBoxes: (where?: BoxWhereInput) => BatchPayloadPromise;
  createCons: (data: ConsCreateInput) => ConsPromise;
  updateCons: (args: {
    data: ConsUpdateInput;
    where: ConsWhereUniqueInput;
  }) => ConsPromise;
  updateManyConses: (args: {
    data: ConsUpdateManyMutationInput;
    where?: ConsWhereInput;
  }) => BatchPayloadPromise;
  upsertCons: (args: {
    where: ConsWhereUniqueInput;
    create: ConsCreateInput;
    update: ConsUpdateInput;
  }) => ConsPromise;
  deleteCons: (where: ConsWhereUniqueInput) => ConsPromise;
  deleteManyConses: (where?: ConsWhereInput) => BatchPayloadPromise;
  createFaq: (data: FaqCreateInput) => FaqPromise;
  updateFaq: (args: {
    data: FaqUpdateInput;
    where: FaqWhereUniqueInput;
  }) => FaqPromise;
  updateManyFaqs: (args: {
    data: FaqUpdateManyMutationInput;
    where?: FaqWhereInput;
  }) => BatchPayloadPromise;
  upsertFaq: (args: {
    where: FaqWhereUniqueInput;
    create: FaqCreateInput;
    update: FaqUpdateInput;
  }) => FaqPromise;
  deleteFaq: (where: FaqWhereUniqueInput) => FaqPromise;
  deleteManyFaqs: (where?: FaqWhereInput) => BatchPayloadPromise;
  createFaqCategory: (data: FaqCategoryCreateInput) => FaqCategoryPromise;
  updateFaqCategory: (args: {
    data: FaqCategoryUpdateInput;
    where: FaqCategoryWhereUniqueInput;
  }) => FaqCategoryPromise;
  updateManyFaqCategories: (args: {
    data: FaqCategoryUpdateManyMutationInput;
    where?: FaqCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertFaqCategory: (args: {
    where: FaqCategoryWhereUniqueInput;
    create: FaqCategoryCreateInput;
    update: FaqCategoryUpdateInput;
  }) => FaqCategoryPromise;
  deleteFaqCategory: (where: FaqCategoryWhereUniqueInput) => FaqCategoryPromise;
  deleteManyFaqCategories: (
    where?: FaqCategoryWhereInput
  ) => BatchPayloadPromise;
  createGrid: (data: GridCreateInput) => GridPromise;
  updateGrid: (args: {
    data: GridUpdateInput;
    where: GridWhereUniqueInput;
  }) => GridPromise;
  updateManyGrids: (args: {
    data: GridUpdateManyMutationInput;
    where?: GridWhereInput;
  }) => BatchPayloadPromise;
  upsertGrid: (args: {
    where: GridWhereUniqueInput;
    create: GridCreateInput;
    update: GridUpdateInput;
  }) => GridPromise;
  deleteGrid: (where: GridWhereUniqueInput) => GridPromise;
  deleteManyGrids: (where?: GridWhereInput) => BatchPayloadPromise;
  createGridItem: (data: GridItemCreateInput) => GridItemPromise;
  updateGridItem: (args: {
    data: GridItemUpdateInput;
    where: GridItemWhereUniqueInput;
  }) => GridItemPromise;
  updateManyGridItems: (args: {
    data: GridItemUpdateManyMutationInput;
    where?: GridItemWhereInput;
  }) => BatchPayloadPromise;
  upsertGridItem: (args: {
    where: GridItemWhereUniqueInput;
    create: GridItemCreateInput;
    update: GridItemUpdateInput;
  }) => GridItemPromise;
  deleteGridItem: (where: GridItemWhereUniqueInput) => GridItemPromise;
  deleteManyGridItems: (where?: GridItemWhereInput) => BatchPayloadPromise;
  createMedia: (data: MediaCreateInput) => MediaPromise;
  updateMedia: (args: {
    data: MediaUpdateInput;
    where: MediaWhereUniqueInput;
  }) => MediaPromise;
  updateManyMedias: (args: {
    data: MediaUpdateManyMutationInput;
    where?: MediaWhereInput;
  }) => BatchPayloadPromise;
  upsertMedia: (args: {
    where: MediaWhereUniqueInput;
    create: MediaCreateInput;
    update: MediaUpdateInput;
  }) => MediaPromise;
  deleteMedia: (where: MediaWhereUniqueInput) => MediaPromise;
  deleteManyMedias: (where?: MediaWhereInput) => BatchPayloadPromise;
  createPage: (data: PageCreateInput) => PagePromise;
  updatePage: (args: {
    data: PageUpdateInput;
    where: PageWhereUniqueInput;
  }) => PagePromise;
  updateManyPages: (args: {
    data: PageUpdateManyMutationInput;
    where?: PageWhereInput;
  }) => BatchPayloadPromise;
  upsertPage: (args: {
    where: PageWhereUniqueInput;
    create: PageCreateInput;
    update: PageUpdateInput;
  }) => PagePromise;
  deletePage: (where: PageWhereUniqueInput) => PagePromise;
  deleteManyPages: (where?: PageWhereInput) => BatchPayloadPromise;
  createPageFaq: (data: PageFaqCreateInput) => PageFaqPromise;
  updatePageFaq: (args: {
    data: PageFaqUpdateInput;
    where: PageFaqWhereUniqueInput;
  }) => PageFaqPromise;
  updateManyPageFaqs: (args: {
    data: PageFaqUpdateManyMutationInput;
    where?: PageFaqWhereInput;
  }) => BatchPayloadPromise;
  upsertPageFaq: (args: {
    where: PageFaqWhereUniqueInput;
    create: PageFaqCreateInput;
    update: PageFaqUpdateInput;
  }) => PageFaqPromise;
  deletePageFaq: (where: PageFaqWhereUniqueInput) => PageFaqPromise;
  deleteManyPageFaqs: (where?: PageFaqWhereInput) => BatchPayloadPromise;
  createPageFaqAccordion: (
    data: PageFaqAccordionCreateInput
  ) => PageFaqAccordionPromise;
  updatePageFaqAccordion: (args: {
    data: PageFaqAccordionUpdateInput;
    where: PageFaqAccordionWhereUniqueInput;
  }) => PageFaqAccordionPromise;
  updateManyPageFaqAccordions: (args: {
    data: PageFaqAccordionUpdateManyMutationInput;
    where?: PageFaqAccordionWhereInput;
  }) => BatchPayloadPromise;
  upsertPageFaqAccordion: (args: {
    where: PageFaqAccordionWhereUniqueInput;
    create: PageFaqAccordionCreateInput;
    update: PageFaqAccordionUpdateInput;
  }) => PageFaqAccordionPromise;
  deletePageFaqAccordion: (
    where: PageFaqAccordionWhereUniqueInput
  ) => PageFaqAccordionPromise;
  deleteManyPageFaqAccordions: (
    where?: PageFaqAccordionWhereInput
  ) => BatchPayloadPromise;
  createPros: (data: ProsCreateInput) => ProsPromise;
  updatePros: (args: {
    data: ProsUpdateInput;
    where: ProsWhereUniqueInput;
  }) => ProsPromise;
  updateManyProses: (args: {
    data: ProsUpdateManyMutationInput;
    where?: ProsWhereInput;
  }) => BatchPayloadPromise;
  upsertPros: (args: {
    where: ProsWhereUniqueInput;
    create: ProsCreateInput;
    update: ProsUpdateInput;
  }) => ProsPromise;
  deletePros: (where: ProsWhereUniqueInput) => ProsPromise;
  deleteManyProses: (where?: ProsWhereInput) => BatchPayloadPromise;
  createProsAndCons: (data: ProsAndConsCreateInput) => ProsAndConsPromise;
  updateProsAndCons: (args: {
    data: ProsAndConsUpdateInput;
    where: ProsAndConsWhereUniqueInput;
  }) => ProsAndConsPromise;
  updateManyProsAndConses: (args: {
    data: ProsAndConsUpdateManyMutationInput;
    where?: ProsAndConsWhereInput;
  }) => BatchPayloadPromise;
  upsertProsAndCons: (args: {
    where: ProsAndConsWhereUniqueInput;
    create: ProsAndConsCreateInput;
    update: ProsAndConsUpdateInput;
  }) => ProsAndConsPromise;
  deleteProsAndCons: (where: ProsAndConsWhereUniqueInput) => ProsAndConsPromise;
  deleteManyProsAndConses: (
    where?: ProsAndConsWhereInput
  ) => BatchPayloadPromise;
  createQuickTip: (data: QuickTipCreateInput) => QuickTipPromise;
  updateQuickTip: (args: {
    data: QuickTipUpdateInput;
    where: QuickTipWhereUniqueInput;
  }) => QuickTipPromise;
  updateManyQuickTips: (args: {
    data: QuickTipUpdateManyMutationInput;
    where?: QuickTipWhereInput;
  }) => BatchPayloadPromise;
  upsertQuickTip: (args: {
    where: QuickTipWhereUniqueInput;
    create: QuickTipCreateInput;
    update: QuickTipUpdateInput;
  }) => QuickTipPromise;
  deleteQuickTip: (where: QuickTipWhereUniqueInput) => QuickTipPromise;
  deleteManyQuickTips: (where?: QuickTipWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  alertBox: (
    where?: AlertBoxSubscriptionWhereInput
  ) => AlertBoxSubscriptionPayloadSubscription;
  block: (
    where?: BlockSubscriptionWhereInput
  ) => BlockSubscriptionPayloadSubscription;
  box: (
    where?: BoxSubscriptionWhereInput
  ) => BoxSubscriptionPayloadSubscription;
  cons: (
    where?: ConsSubscriptionWhereInput
  ) => ConsSubscriptionPayloadSubscription;
  faq: (
    where?: FaqSubscriptionWhereInput
  ) => FaqSubscriptionPayloadSubscription;
  faqCategory: (
    where?: FaqCategorySubscriptionWhereInput
  ) => FaqCategorySubscriptionPayloadSubscription;
  grid: (
    where?: GridSubscriptionWhereInput
  ) => GridSubscriptionPayloadSubscription;
  gridItem: (
    where?: GridItemSubscriptionWhereInput
  ) => GridItemSubscriptionPayloadSubscription;
  media: (
    where?: MediaSubscriptionWhereInput
  ) => MediaSubscriptionPayloadSubscription;
  page: (
    where?: PageSubscriptionWhereInput
  ) => PageSubscriptionPayloadSubscription;
  pageFaq: (
    where?: PageFaqSubscriptionWhereInput
  ) => PageFaqSubscriptionPayloadSubscription;
  pageFaqAccordion: (
    where?: PageFaqAccordionSubscriptionWhereInput
  ) => PageFaqAccordionSubscriptionPayloadSubscription;
  pros: (
    where?: ProsSubscriptionWhereInput
  ) => ProsSubscriptionPayloadSubscription;
  prosAndCons: (
    where?: ProsAndConsSubscriptionWhereInput
  ) => ProsAndConsSubscriptionPayloadSubscription;
  quickTip: (
    where?: QuickTipSubscriptionWhereInput
  ) => QuickTipSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FaqCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BlockOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "video_ASC"
  | "video_DESC"
  | "alignment_ASC"
  | "alignment_DESC"
  | "content_ASC"
  | "content_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Permission = "ADMIN" | "USER";

export type PageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "url_ASC"
  | "url_DESC"
  | "type_ASC"
  | "type_DESC"
  | "status_ASC"
  | "status_DESC"
  | "content_ASC"
  | "content_DESC"
  | "vertical_ASC"
  | "vertical_DESC"
  | "template_ASC"
  | "template_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PageType = "PAGE" | "NEWS" | "ARTICLE" | "STATIC" | "GUIDE";

export type PageFaqOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC";

export type GridItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "linkText_ASC"
  | "linkText_DESC"
  | "linkUrl_ASC"
  | "linkUrl_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type QuickTipOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "buttonText_ASC"
  | "buttonText_DESC"
  | "buttonLink_ASC"
  | "buttonLink_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PageFaqAccordionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC";

export type AlertBoxOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "prefix_ASC"
  | "prefix_DESC"
  | "style_ASC"
  | "style_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BoxOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "video_ASC"
  | "video_DESC"
  | "style_ASC"
  | "style_DESC"
  | "alignment_ASC"
  | "alignment_DESC"
  | "content_ASC"
  | "content_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProsAndConsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ConsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MediaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "title_ASC"
  | "title_DESC"
  | "altText_ASC"
  | "altText_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FaqOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "short_description_ASC"
  | "short_description_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "vertical_ASC"
  | "vertical_DESC"
  | "readingTime_ASC"
  | "readingTime_DESC"
  | "order_ASC"
  | "order_DESC"
  | "pubDate_ASC"
  | "pubDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GridOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PageStatus = "DRAFT" | "PUBLISHED" | "DELETED";

export interface PageFaqUpdateWithWhereUniqueWithoutPageInput {
  where: PageFaqWhereUniqueInput;
  data: PageFaqUpdateWithoutPageDataInput;
}

export type AlertBoxWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BlockUpdateWithoutPageDataInput {
  title?: String;
  media?: MediaUpdateOneInput;
  video?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface PageCreateWithoutGridsInput {
  id?: ID_Input;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaCreateOneInput;
  template?: String;
  blocks?: BlockCreateManyWithoutPageInput;
  boxes?: BoxCreateManyWithoutPageInput;
  prosAndCons?: ProsAndConsCreateManyWithoutPageInput;
  alertBoxes?: AlertBoxCreateManyWithoutPageInput;
  quickTips?: QuickTipCreateManyWithoutPageInput;
  faqs?: PageFaqCreateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionCreateManyWithoutPageInput;
}

export interface BlockUpsertWithWhereUniqueWithoutPageInput {
  where: BlockWhereUniqueInput;
  update: BlockUpdateWithoutPageDataInput;
  create: BlockCreateWithoutPageInput;
}

export interface UserUpdateManyDataInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserUpdatepermissionsInput;
}

export interface BlockScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  video?: String;
  video_not?: String;
  video_in?: String[] | String;
  video_not_in?: String[] | String;
  video_lt?: String;
  video_lte?: String;
  video_gt?: String;
  video_gte?: String;
  video_contains?: String;
  video_not_contains?: String;
  video_starts_with?: String;
  video_not_starts_with?: String;
  video_ends_with?: String;
  video_not_ends_with?: String;
  alignment?: String;
  alignment_not?: String;
  alignment_in?: String[] | String;
  alignment_not_in?: String[] | String;
  alignment_lt?: String;
  alignment_lte?: String;
  alignment_gt?: String;
  alignment_gte?: String;
  alignment_contains?: String;
  alignment_not_contains?: String;
  alignment_starts_with?: String;
  alignment_not_starts_with?: String;
  alignment_ends_with?: String;
  alignment_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BlockScalarWhereInput[] | BlockScalarWhereInput;
  OR?: BlockScalarWhereInput[] | BlockScalarWhereInput;
  NOT?: BlockScalarWhereInput[] | BlockScalarWhereInput;
}

export interface GridWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  page?: PageWhereInput;
  media?: MediaWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  items_every?: GridItemWhereInput;
  items_some?: GridItemWhereInput;
  items_none?: GridItemWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: GridWhereInput[] | GridWhereInput;
  OR?: GridWhereInput[] | GridWhereInput;
  NOT?: GridWhereInput[] | GridWhereInput;
}

export interface BlockUpdateManyWithWhereNestedInput {
  where: BlockScalarWhereInput;
  data: BlockUpdateManyDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  resetToken?: String;
  resetToken_not?: String;
  resetToken_in?: String[] | String;
  resetToken_not_in?: String[] | String;
  resetToken_lt?: String;
  resetToken_lte?: String;
  resetToken_gt?: String;
  resetToken_gte?: String;
  resetToken_contains?: String;
  resetToken_not_contains?: String;
  resetToken_starts_with?: String;
  resetToken_not_starts_with?: String;
  resetToken_ends_with?: String;
  resetToken_not_ends_with?: String;
  resetTokenExpiry?: Float;
  resetTokenExpiry_not?: Float;
  resetTokenExpiry_in?: Float[] | Float;
  resetTokenExpiry_not_in?: Float[] | Float;
  resetTokenExpiry_lt?: Float;
  resetTokenExpiry_lte?: Float;
  resetTokenExpiry_gt?: Float;
  resetTokenExpiry_gte?: Float;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface BlockUpdateManyDataInput {
  title?: String;
  video?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface FaqWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  short_description?: String;
  short_description_not?: String;
  short_description_in?: String[] | String;
  short_description_not_in?: String[] | String;
  short_description_lt?: String;
  short_description_lte?: String;
  short_description_gt?: String;
  short_description_gte?: String;
  short_description_contains?: String;
  short_description_not_contains?: String;
  short_description_starts_with?: String;
  short_description_not_starts_with?: String;
  short_description_ends_with?: String;
  short_description_not_ends_with?: String;
  authors_every?: UserWhereInput;
  authors_some?: UserWhereInput;
  authors_none?: UserWhereInput;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  vertical?: String;
  vertical_not?: String;
  vertical_in?: String[] | String;
  vertical_not_in?: String[] | String;
  vertical_lt?: String;
  vertical_lte?: String;
  vertical_gt?: String;
  vertical_gte?: String;
  vertical_contains?: String;
  vertical_not_contains?: String;
  vertical_starts_with?: String;
  vertical_not_starts_with?: String;
  vertical_ends_with?: String;
  vertical_not_ends_with?: String;
  category_every?: FaqCategoryWhereInput;
  category_some?: FaqCategoryWhereInput;
  category_none?: FaqCategoryWhereInput;
  readingTime?: Int;
  readingTime_not?: Int;
  readingTime_in?: Int[] | Int;
  readingTime_not_in?: Int[] | Int;
  readingTime_lt?: Int;
  readingTime_lte?: Int;
  readingTime_gt?: Int;
  readingTime_gte?: Int;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  pubDate?: DateTimeInput;
  pubDate_not?: DateTimeInput;
  pubDate_in?: DateTimeInput[] | DateTimeInput;
  pubDate_not_in?: DateTimeInput[] | DateTimeInput;
  pubDate_lt?: DateTimeInput;
  pubDate_lte?: DateTimeInput;
  pubDate_gt?: DateTimeInput;
  pubDate_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FaqWhereInput[] | FaqWhereInput;
  OR?: FaqWhereInput[] | FaqWhereInput;
  NOT?: FaqWhereInput[] | FaqWhereInput;
}

export interface BoxUpdateManyWithoutPageInput {
  create?: BoxCreateWithoutPageInput[] | BoxCreateWithoutPageInput;
  delete?: BoxWhereUniqueInput[] | BoxWhereUniqueInput;
  connect?: BoxWhereUniqueInput[] | BoxWhereUniqueInput;
  set?: BoxWhereUniqueInput[] | BoxWhereUniqueInput;
  disconnect?: BoxWhereUniqueInput[] | BoxWhereUniqueInput;
  update?:
    | BoxUpdateWithWhereUniqueWithoutPageInput[]
    | BoxUpdateWithWhereUniqueWithoutPageInput;
  upsert?:
    | BoxUpsertWithWhereUniqueWithoutPageInput[]
    | BoxUpsertWithWhereUniqueWithoutPageInput;
  deleteMany?: BoxScalarWhereInput[] | BoxScalarWhereInput;
  updateMany?:
    | BoxUpdateManyWithWhereNestedInput[]
    | BoxUpdateManyWithWhereNestedInput;
}

export interface PageFaqWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  page?: PageWhereInput;
  faq?: FaqWhereInput;
  AND?: PageFaqWhereInput[] | PageFaqWhereInput;
  OR?: PageFaqWhereInput[] | PageFaqWhereInput;
  NOT?: PageFaqWhereInput[] | PageFaqWhereInput;
}

export interface BoxUpdateWithWhereUniqueWithoutPageInput {
  where: BoxWhereUniqueInput;
  data: BoxUpdateWithoutPageDataInput;
}

export interface QuickTipWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  page?: PageWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  buttonText?: String;
  buttonText_not?: String;
  buttonText_in?: String[] | String;
  buttonText_not_in?: String[] | String;
  buttonText_lt?: String;
  buttonText_lte?: String;
  buttonText_gt?: String;
  buttonText_gte?: String;
  buttonText_contains?: String;
  buttonText_not_contains?: String;
  buttonText_starts_with?: String;
  buttonText_not_starts_with?: String;
  buttonText_ends_with?: String;
  buttonText_not_ends_with?: String;
  buttonLink?: String;
  buttonLink_not?: String;
  buttonLink_in?: String[] | String;
  buttonLink_not_in?: String[] | String;
  buttonLink_lt?: String;
  buttonLink_lte?: String;
  buttonLink_gt?: String;
  buttonLink_gte?: String;
  buttonLink_contains?: String;
  buttonLink_not_contains?: String;
  buttonLink_starts_with?: String;
  buttonLink_not_starts_with?: String;
  buttonLink_ends_with?: String;
  buttonLink_not_ends_with?: String;
  media?: MediaWhereInput;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: QuickTipWhereInput[] | QuickTipWhereInput;
  OR?: QuickTipWhereInput[] | QuickTipWhereInput;
  NOT?: QuickTipWhereInput[] | QuickTipWhereInput;
}

export interface BoxUpdateWithoutPageDataInput {
  title?: String;
  media?: MediaUpdateOneInput;
  video?: String;
  style?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface AlertBoxWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  page?: PageWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  prefix?: String;
  prefix_not?: String;
  prefix_in?: String[] | String;
  prefix_not_in?: String[] | String;
  prefix_lt?: String;
  prefix_lte?: String;
  prefix_gt?: String;
  prefix_gte?: String;
  prefix_contains?: String;
  prefix_not_contains?: String;
  prefix_starts_with?: String;
  prefix_not_starts_with?: String;
  prefix_ends_with?: String;
  prefix_not_ends_with?: String;
  style?: String;
  style_not?: String;
  style_in?: String[] | String;
  style_not_in?: String[] | String;
  style_lt?: String;
  style_lte?: String;
  style_gt?: String;
  style_gte?: String;
  style_contains?: String;
  style_not_contains?: String;
  style_starts_with?: String;
  style_not_starts_with?: String;
  style_ends_with?: String;
  style_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AlertBoxWhereInput[] | AlertBoxWhereInput;
  OR?: AlertBoxWhereInput[] | AlertBoxWhereInput;
  NOT?: AlertBoxWhereInput[] | AlertBoxWhereInput;
}

export interface BoxUpsertWithWhereUniqueWithoutPageInput {
  where: BoxWhereUniqueInput;
  update: BoxUpdateWithoutPageDataInput;
  create: BoxCreateWithoutPageInput;
}

export interface ConsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  prosAndCons?: ProsAndConsWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ConsWhereInput[] | ConsWhereInput;
  OR?: ConsWhereInput[] | ConsWhereInput;
  NOT?: ConsWhereInput[] | ConsWhereInput;
}

export interface BoxScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  video?: String;
  video_not?: String;
  video_in?: String[] | String;
  video_not_in?: String[] | String;
  video_lt?: String;
  video_lte?: String;
  video_gt?: String;
  video_gte?: String;
  video_contains?: String;
  video_not_contains?: String;
  video_starts_with?: String;
  video_not_starts_with?: String;
  video_ends_with?: String;
  video_not_ends_with?: String;
  style?: String;
  style_not?: String;
  style_in?: String[] | String;
  style_not_in?: String[] | String;
  style_lt?: String;
  style_lte?: String;
  style_gt?: String;
  style_gte?: String;
  style_contains?: String;
  style_not_contains?: String;
  style_starts_with?: String;
  style_not_starts_with?: String;
  style_ends_with?: String;
  style_not_ends_with?: String;
  alignment?: String;
  alignment_not?: String;
  alignment_in?: String[] | String;
  alignment_not_in?: String[] | String;
  alignment_lt?: String;
  alignment_lte?: String;
  alignment_gt?: String;
  alignment_gte?: String;
  alignment_contains?: String;
  alignment_not_contains?: String;
  alignment_starts_with?: String;
  alignment_not_starts_with?: String;
  alignment_ends_with?: String;
  alignment_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BoxScalarWhereInput[] | BoxScalarWhereInput;
  OR?: BoxScalarWhereInput[] | BoxScalarWhereInput;
  NOT?: BoxScalarWhereInput[] | BoxScalarWhereInput;
}

export interface PageFaqSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PageFaqWhereInput;
  AND?: PageFaqSubscriptionWhereInput[] | PageFaqSubscriptionWhereInput;
  OR?: PageFaqSubscriptionWhereInput[] | PageFaqSubscriptionWhereInput;
  NOT?: PageFaqSubscriptionWhereInput[] | PageFaqSubscriptionWhereInput;
}

export interface BoxUpdateManyWithWhereNestedInput {
  where: BoxScalarWhereInput;
  data: BoxUpdateManyDataInput;
}

export interface PageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PageWhereInput;
  AND?: PageSubscriptionWhereInput[] | PageSubscriptionWhereInput;
  OR?: PageSubscriptionWhereInput[] | PageSubscriptionWhereInput;
  NOT?: PageSubscriptionWhereInput[] | PageSubscriptionWhereInput;
}

export interface BoxUpdateManyDataInput {
  title?: String;
  video?: String;
  style?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface GridItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GridItemWhereInput;
  AND?: GridItemSubscriptionWhereInput[] | GridItemSubscriptionWhereInput;
  OR?: GridItemSubscriptionWhereInput[] | GridItemSubscriptionWhereInput;
  NOT?: GridItemSubscriptionWhereInput[] | GridItemSubscriptionWhereInput;
}

export interface ProsAndConsUpdateManyWithoutPageInput {
  create?:
    | ProsAndConsCreateWithoutPageInput[]
    | ProsAndConsCreateWithoutPageInput;
  delete?: ProsAndConsWhereUniqueInput[] | ProsAndConsWhereUniqueInput;
  connect?: ProsAndConsWhereUniqueInput[] | ProsAndConsWhereUniqueInput;
  set?: ProsAndConsWhereUniqueInput[] | ProsAndConsWhereUniqueInput;
  disconnect?: ProsAndConsWhereUniqueInput[] | ProsAndConsWhereUniqueInput;
  update?:
    | ProsAndConsUpdateWithWhereUniqueWithoutPageInput[]
    | ProsAndConsUpdateWithWhereUniqueWithoutPageInput;
  upsert?:
    | ProsAndConsUpsertWithWhereUniqueWithoutPageInput[]
    | ProsAndConsUpsertWithWhereUniqueWithoutPageInput;
  deleteMany?: ProsAndConsScalarWhereInput[] | ProsAndConsScalarWhereInput;
  updateMany?:
    | ProsAndConsUpdateManyWithWhereNestedInput[]
    | ProsAndConsUpdateManyWithWhereNestedInput;
}

export interface BoxWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  page?: PageWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  media?: MediaWhereInput;
  video?: String;
  video_not?: String;
  video_in?: String[] | String;
  video_not_in?: String[] | String;
  video_lt?: String;
  video_lte?: String;
  video_gt?: String;
  video_gte?: String;
  video_contains?: String;
  video_not_contains?: String;
  video_starts_with?: String;
  video_not_starts_with?: String;
  video_ends_with?: String;
  video_not_ends_with?: String;
  style?: String;
  style_not?: String;
  style_in?: String[] | String;
  style_not_in?: String[] | String;
  style_lt?: String;
  style_lte?: String;
  style_gt?: String;
  style_gte?: String;
  style_contains?: String;
  style_not_contains?: String;
  style_starts_with?: String;
  style_not_starts_with?: String;
  style_ends_with?: String;
  style_not_ends_with?: String;
  alignment?: String;
  alignment_not?: String;
  alignment_in?: String[] | String;
  alignment_not_in?: String[] | String;
  alignment_lt?: String;
  alignment_lte?: String;
  alignment_gt?: String;
  alignment_gte?: String;
  alignment_contains?: String;
  alignment_not_contains?: String;
  alignment_starts_with?: String;
  alignment_not_starts_with?: String;
  alignment_ends_with?: String;
  alignment_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BoxWhereInput[] | BoxWhereInput;
  OR?: BoxWhereInput[] | BoxWhereInput;
  NOT?: BoxWhereInput[] | BoxWhereInput;
}

export interface ProsAndConsUpdateWithWhereUniqueWithoutPageInput {
  where: ProsAndConsWhereUniqueInput;
  data: ProsAndConsUpdateWithoutPageDataInput;
}

export interface FaqCategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FaqCategoryWhereInput;
  AND?: FaqCategorySubscriptionWhereInput[] | FaqCategorySubscriptionWhereInput;
  OR?: FaqCategorySubscriptionWhereInput[] | FaqCategorySubscriptionWhereInput;
  NOT?: FaqCategorySubscriptionWhereInput[] | FaqCategorySubscriptionWhereInput;
}

export interface ProsAndConsUpdateWithoutPageDataInput {
  title?: String;
  order?: Int;
  pros?: ProsUpdateManyWithoutProsAndConsInput;
  cons?: ConsUpdateManyWithoutProsAndConsInput;
}

export interface BlockWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  page?: PageWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  media?: MediaWhereInput;
  video?: String;
  video_not?: String;
  video_in?: String[] | String;
  video_not_in?: String[] | String;
  video_lt?: String;
  video_lte?: String;
  video_gt?: String;
  video_gte?: String;
  video_contains?: String;
  video_not_contains?: String;
  video_starts_with?: String;
  video_not_starts_with?: String;
  video_ends_with?: String;
  video_not_ends_with?: String;
  alignment?: String;
  alignment_not?: String;
  alignment_in?: String[] | String;
  alignment_not_in?: String[] | String;
  alignment_lt?: String;
  alignment_lte?: String;
  alignment_gt?: String;
  alignment_gte?: String;
  alignment_contains?: String;
  alignment_not_contains?: String;
  alignment_starts_with?: String;
  alignment_not_starts_with?: String;
  alignment_ends_with?: String;
  alignment_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BlockWhereInput[] | BlockWhereInput;
  OR?: BlockWhereInput[] | BlockWhereInput;
  NOT?: BlockWhereInput[] | BlockWhereInput;
}

export interface ProsUpdateManyWithoutProsAndConsInput {
  create?:
    | ProsCreateWithoutProsAndConsInput[]
    | ProsCreateWithoutProsAndConsInput;
  delete?: ProsWhereUniqueInput[] | ProsWhereUniqueInput;
  connect?: ProsWhereUniqueInput[] | ProsWhereUniqueInput;
  set?: ProsWhereUniqueInput[] | ProsWhereUniqueInput;
  disconnect?: ProsWhereUniqueInput[] | ProsWhereUniqueInput;
  update?:
    | ProsUpdateWithWhereUniqueWithoutProsAndConsInput[]
    | ProsUpdateWithWhereUniqueWithoutProsAndConsInput;
  upsert?:
    | ProsUpsertWithWhereUniqueWithoutProsAndConsInput[]
    | ProsUpsertWithWhereUniqueWithoutProsAndConsInput;
  deleteMany?: ProsScalarWhereInput[] | ProsScalarWhereInput;
  updateMany?:
    | ProsUpdateManyWithWhereNestedInput[]
    | ProsUpdateManyWithWhereNestedInput;
}

export interface ConsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ConsWhereInput;
  AND?: ConsSubscriptionWhereInput[] | ConsSubscriptionWhereInput;
  OR?: ConsSubscriptionWhereInput[] | ConsSubscriptionWhereInput;
  NOT?: ConsSubscriptionWhereInput[] | ConsSubscriptionWhereInput;
}

export interface ProsUpdateWithWhereUniqueWithoutProsAndConsInput {
  where: ProsWhereUniqueInput;
  data: ProsUpdateWithoutProsAndConsDataInput;
}

export interface BlockSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BlockWhereInput;
  AND?: BlockSubscriptionWhereInput[] | BlockSubscriptionWhereInput;
  OR?: BlockSubscriptionWhereInput[] | BlockSubscriptionWhereInput;
  NOT?: BlockSubscriptionWhereInput[] | BlockSubscriptionWhereInput;
}

export interface ProsUpdateWithoutProsAndConsDataInput {
  content?: String;
  order?: Int;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserUpdatepermissionsInput;
}

export interface ProsUpsertWithWhereUniqueWithoutProsAndConsInput {
  where: ProsWhereUniqueInput;
  update: ProsUpdateWithoutProsAndConsDataInput;
  create: ProsCreateWithoutProsAndConsInput;
}

export interface QuickTipUpdateManyMutationInput {
  title?: String;
  content?: String;
  buttonText?: String;
  buttonLink?: String;
  order?: Int;
}

export interface ProsScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProsScalarWhereInput[] | ProsScalarWhereInput;
  OR?: ProsScalarWhereInput[] | ProsScalarWhereInput;
  NOT?: ProsScalarWhereInput[] | ProsScalarWhereInput;
}

export interface PageUpdateWithoutQuickTipsDataInput {
  title?: String;
  slug?: String;
  url?: String;
  type?: PageType;
  status?: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaUpdateOneInput;
  template?: String;
  blocks?: BlockUpdateManyWithoutPageInput;
  boxes?: BoxUpdateManyWithoutPageInput;
  prosAndCons?: ProsAndConsUpdateManyWithoutPageInput;
  alertBoxes?: AlertBoxUpdateManyWithoutPageInput;
  faqs?: PageFaqUpdateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionUpdateManyWithoutPageInput;
  grids?: GridUpdateManyWithoutPageInput;
}

export interface ProsUpdateManyWithWhereNestedInput {
  where: ProsScalarWhereInput;
  data: ProsUpdateManyDataInput;
}

export interface PageUpdateOneRequiredWithoutQuickTipsInput {
  create?: PageCreateWithoutQuickTipsInput;
  update?: PageUpdateWithoutQuickTipsDataInput;
  upsert?: PageUpsertWithoutQuickTipsInput;
  connect?: PageWhereUniqueInput;
}

export interface ProsUpdateManyDataInput {
  content?: String;
  order?: Int;
}

export interface PageCreateWithoutQuickTipsInput {
  id?: ID_Input;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaCreateOneInput;
  template?: String;
  blocks?: BlockCreateManyWithoutPageInput;
  boxes?: BoxCreateManyWithoutPageInput;
  prosAndCons?: ProsAndConsCreateManyWithoutPageInput;
  alertBoxes?: AlertBoxCreateManyWithoutPageInput;
  faqs?: PageFaqCreateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionCreateManyWithoutPageInput;
  grids?: GridCreateManyWithoutPageInput;
}

export interface ConsUpdateManyWithoutProsAndConsInput {
  create?:
    | ConsCreateWithoutProsAndConsInput[]
    | ConsCreateWithoutProsAndConsInput;
  delete?: ConsWhereUniqueInput[] | ConsWhereUniqueInput;
  connect?: ConsWhereUniqueInput[] | ConsWhereUniqueInput;
  set?: ConsWhereUniqueInput[] | ConsWhereUniqueInput;
  disconnect?: ConsWhereUniqueInput[] | ConsWhereUniqueInput;
  update?:
    | ConsUpdateWithWhereUniqueWithoutProsAndConsInput[]
    | ConsUpdateWithWhereUniqueWithoutProsAndConsInput;
  upsert?:
    | ConsUpsertWithWhereUniqueWithoutProsAndConsInput[]
    | ConsUpsertWithWhereUniqueWithoutProsAndConsInput;
  deleteMany?: ConsScalarWhereInput[] | ConsScalarWhereInput;
  updateMany?:
    | ConsUpdateManyWithWhereNestedInput[]
    | ConsUpdateManyWithWhereNestedInput;
}

export interface PageCreateOneWithoutQuickTipsInput {
  create?: PageCreateWithoutQuickTipsInput;
  connect?: PageWhereUniqueInput;
}

export interface ConsUpdateWithWhereUniqueWithoutProsAndConsInput {
  where: ConsWhereUniqueInput;
  data: ConsUpdateWithoutProsAndConsDataInput;
}

export interface ProsAndConsUpdateManyMutationInput {
  title?: String;
  order?: Int;
}

export interface ConsUpdateWithoutProsAndConsDataInput {
  content?: String;
  order?: Int;
}

export interface ProsAndConsUpdateInput {
  page?: PageUpdateOneRequiredWithoutProsAndConsInput;
  title?: String;
  order?: Int;
  pros?: ProsUpdateManyWithoutProsAndConsInput;
  cons?: ConsUpdateManyWithoutProsAndConsInput;
}

export interface ConsUpsertWithWhereUniqueWithoutProsAndConsInput {
  where: ConsWhereUniqueInput;
  update: ConsUpdateWithoutProsAndConsDataInput;
  create: ConsCreateWithoutProsAndConsInput;
}

export interface ProsUpdateManyMutationInput {
  content?: String;
  order?: Int;
}

export interface ConsScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ConsScalarWhereInput[] | ConsScalarWhereInput;
  OR?: ConsScalarWhereInput[] | ConsScalarWhereInput;
  NOT?: ConsScalarWhereInput[] | ConsScalarWhereInput;
}

export interface ProsAndConsUpsertWithoutProsInput {
  update: ProsAndConsUpdateWithoutProsDataInput;
  create: ProsAndConsCreateWithoutProsInput;
}

export interface ConsUpdateManyWithWhereNestedInput {
  where: ConsScalarWhereInput;
  data: ConsUpdateManyDataInput;
}

export interface ProsAndConsUpdateOneRequiredWithoutProsInput {
  create?: ProsAndConsCreateWithoutProsInput;
  update?: ProsAndConsUpdateWithoutProsDataInput;
  upsert?: ProsAndConsUpsertWithoutProsInput;
  connect?: ProsAndConsWhereUniqueInput;
}

export interface ConsUpdateManyDataInput {
  content?: String;
  order?: Int;
}

export interface ProsUpdateInput {
  prosAndCons?: ProsAndConsUpdateOneRequiredWithoutProsInput;
  content?: String;
  order?: Int;
}

export interface ProsAndConsUpsertWithWhereUniqueWithoutPageInput {
  where: ProsAndConsWhereUniqueInput;
  update: ProsAndConsUpdateWithoutPageDataInput;
  create: ProsAndConsCreateWithoutPageInput;
}

export interface ProsAndConsCreateOneWithoutProsInput {
  create?: ProsAndConsCreateWithoutProsInput;
  connect?: ProsAndConsWhereUniqueInput;
}

export interface ProsAndConsScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProsAndConsScalarWhereInput[] | ProsAndConsScalarWhereInput;
  OR?: ProsAndConsScalarWhereInput[] | ProsAndConsScalarWhereInput;
  NOT?: ProsAndConsScalarWhereInput[] | ProsAndConsScalarWhereInput;
}

export interface ProsCreateInput {
  id?: ID_Input;
  prosAndCons: ProsAndConsCreateOneWithoutProsInput;
  content?: String;
  order?: Int;
}

export interface ProsAndConsUpdateManyWithWhereNestedInput {
  where: ProsAndConsScalarWhereInput;
  data: ProsAndConsUpdateManyDataInput;
}

export interface PageUpsertWithoutFaqAccordionInput {
  update: PageUpdateWithoutFaqAccordionDataInput;
  create: PageCreateWithoutFaqAccordionInput;
}

export interface ProsAndConsUpdateManyDataInput {
  title?: String;
  order?: Int;
}

export interface PageUpdateWithoutFaqAccordionDataInput {
  title?: String;
  slug?: String;
  url?: String;
  type?: PageType;
  status?: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaUpdateOneInput;
  template?: String;
  blocks?: BlockUpdateManyWithoutPageInput;
  boxes?: BoxUpdateManyWithoutPageInput;
  prosAndCons?: ProsAndConsUpdateManyWithoutPageInput;
  alertBoxes?: AlertBoxUpdateManyWithoutPageInput;
  quickTips?: QuickTipUpdateManyWithoutPageInput;
  faqs?: PageFaqUpdateManyWithoutPageInput;
  grids?: GridUpdateManyWithoutPageInput;
}

export interface QuickTipUpdateManyWithoutPageInput {
  create?: QuickTipCreateWithoutPageInput[] | QuickTipCreateWithoutPageInput;
  delete?: QuickTipWhereUniqueInput[] | QuickTipWhereUniqueInput;
  connect?: QuickTipWhereUniqueInput[] | QuickTipWhereUniqueInput;
  set?: QuickTipWhereUniqueInput[] | QuickTipWhereUniqueInput;
  disconnect?: QuickTipWhereUniqueInput[] | QuickTipWhereUniqueInput;
  update?:
    | QuickTipUpdateWithWhereUniqueWithoutPageInput[]
    | QuickTipUpdateWithWhereUniqueWithoutPageInput;
  upsert?:
    | QuickTipUpsertWithWhereUniqueWithoutPageInput[]
    | QuickTipUpsertWithWhereUniqueWithoutPageInput;
  deleteMany?: QuickTipScalarWhereInput[] | QuickTipScalarWhereInput;
  updateMany?:
    | QuickTipUpdateManyWithWhereNestedInput[]
    | QuickTipUpdateManyWithWhereNestedInput;
}

export interface PageFaqAccordionUpdateInput {
  order?: Int;
  page?: PageUpdateOneRequiredWithoutFaqAccordionInput;
  faqCategory?: FaqCategoryUpdateOneRequiredInput;
}

export interface QuickTipUpdateWithWhereUniqueWithoutPageInput {
  where: QuickTipWhereUniqueInput;
  data: QuickTipUpdateWithoutPageDataInput;
}

export interface PageCreateWithoutFaqAccordionInput {
  id?: ID_Input;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaCreateOneInput;
  template?: String;
  blocks?: BlockCreateManyWithoutPageInput;
  boxes?: BoxCreateManyWithoutPageInput;
  prosAndCons?: ProsAndConsCreateManyWithoutPageInput;
  alertBoxes?: AlertBoxCreateManyWithoutPageInput;
  quickTips?: QuickTipCreateManyWithoutPageInput;
  faqs?: PageFaqCreateManyWithoutPageInput;
  grids?: GridCreateManyWithoutPageInput;
}

export interface QuickTipUpdateWithoutPageDataInput {
  title?: String;
  content?: String;
  buttonText?: String;
  buttonLink?: String;
  media?: MediaUpdateOneInput;
  order?: Int;
}

export interface PageFaqAccordionCreateInput {
  id?: ID_Input;
  order?: Int;
  page: PageCreateOneWithoutFaqAccordionInput;
  faqCategory: FaqCategoryCreateOneInput;
}

export interface QuickTipUpsertWithWhereUniqueWithoutPageInput {
  where: QuickTipWhereUniqueInput;
  update: QuickTipUpdateWithoutPageDataInput;
  create: QuickTipCreateWithoutPageInput;
}

export type PageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface QuickTipScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  buttonText?: String;
  buttonText_not?: String;
  buttonText_in?: String[] | String;
  buttonText_not_in?: String[] | String;
  buttonText_lt?: String;
  buttonText_lte?: String;
  buttonText_gt?: String;
  buttonText_gte?: String;
  buttonText_contains?: String;
  buttonText_not_contains?: String;
  buttonText_starts_with?: String;
  buttonText_not_starts_with?: String;
  buttonText_ends_with?: String;
  buttonText_not_ends_with?: String;
  buttonLink?: String;
  buttonLink_not?: String;
  buttonLink_in?: String[] | String;
  buttonLink_not_in?: String[] | String;
  buttonLink_lt?: String;
  buttonLink_lte?: String;
  buttonLink_gt?: String;
  buttonLink_gte?: String;
  buttonLink_contains?: String;
  buttonLink_not_contains?: String;
  buttonLink_starts_with?: String;
  buttonLink_not_starts_with?: String;
  buttonLink_ends_with?: String;
  buttonLink_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: QuickTipScalarWhereInput[] | QuickTipScalarWhereInput;
  OR?: QuickTipScalarWhereInput[] | QuickTipScalarWhereInput;
  NOT?: QuickTipScalarWhereInput[] | QuickTipScalarWhereInput;
}

export interface PageUpdateWithoutFaqsDataInput {
  title?: String;
  slug?: String;
  url?: String;
  type?: PageType;
  status?: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaUpdateOneInput;
  template?: String;
  blocks?: BlockUpdateManyWithoutPageInput;
  boxes?: BoxUpdateManyWithoutPageInput;
  prosAndCons?: ProsAndConsUpdateManyWithoutPageInput;
  alertBoxes?: AlertBoxUpdateManyWithoutPageInput;
  quickTips?: QuickTipUpdateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionUpdateManyWithoutPageInput;
  grids?: GridUpdateManyWithoutPageInput;
}

export interface QuickTipUpdateManyWithWhereNestedInput {
  where: QuickTipScalarWhereInput;
  data: QuickTipUpdateManyDataInput;
}

export interface PageFaqUpdateInput {
  order?: Int;
  page?: PageUpdateOneRequiredWithoutFaqsInput;
  faq?: FaqUpdateOneRequiredInput;
}

export interface QuickTipUpdateManyDataInput {
  title?: String;
  content?: String;
  buttonText?: String;
  buttonLink?: String;
  order?: Int;
}

export interface PageCreateWithoutFaqsInput {
  id?: ID_Input;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaCreateOneInput;
  template?: String;
  blocks?: BlockCreateManyWithoutPageInput;
  boxes?: BoxCreateManyWithoutPageInput;
  prosAndCons?: ProsAndConsCreateManyWithoutPageInput;
  alertBoxes?: AlertBoxCreateManyWithoutPageInput;
  quickTips?: QuickTipCreateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionCreateManyWithoutPageInput;
  grids?: GridCreateManyWithoutPageInput;
}

export interface PageFaqUpdateManyWithoutPageInput {
  create?: PageFaqCreateWithoutPageInput[] | PageFaqCreateWithoutPageInput;
  delete?: PageFaqWhereUniqueInput[] | PageFaqWhereUniqueInput;
  connect?: PageFaqWhereUniqueInput[] | PageFaqWhereUniqueInput;
  set?: PageFaqWhereUniqueInput[] | PageFaqWhereUniqueInput;
  disconnect?: PageFaqWhereUniqueInput[] | PageFaqWhereUniqueInput;
  update?:
    | PageFaqUpdateWithWhereUniqueWithoutPageInput[]
    | PageFaqUpdateWithWhereUniqueWithoutPageInput;
  upsert?:
    | PageFaqUpsertWithWhereUniqueWithoutPageInput[]
    | PageFaqUpsertWithWhereUniqueWithoutPageInput;
  deleteMany?: PageFaqScalarWhereInput[] | PageFaqScalarWhereInput;
  updateMany?:
    | PageFaqUpdateManyWithWhereNestedInput[]
    | PageFaqUpdateManyWithWhereNestedInput;
}

export interface PageFaqCreateInput {
  id?: ID_Input;
  order?: Int;
  page: PageCreateOneWithoutFaqsInput;
  faq: FaqCreateOneInput;
}

export interface PageUpdateWithoutGridsDataInput {
  title?: String;
  slug?: String;
  url?: String;
  type?: PageType;
  status?: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaUpdateOneInput;
  template?: String;
  blocks?: BlockUpdateManyWithoutPageInput;
  boxes?: BoxUpdateManyWithoutPageInput;
  prosAndCons?: ProsAndConsUpdateManyWithoutPageInput;
  alertBoxes?: AlertBoxUpdateManyWithoutPageInput;
  quickTips?: QuickTipUpdateManyWithoutPageInput;
  faqs?: PageFaqUpdateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionUpdateManyWithoutPageInput;
}

export interface PageUpdateManyMutationInput {
  title?: String;
  slug?: String;
  url?: String;
  type?: PageType;
  status?: PageStatus;
  content?: String;
  vertical?: String;
  template?: String;
}

export interface PageFaqUpdateWithoutPageDataInput {
  order?: Int;
  faq?: FaqUpdateOneRequiredInput;
}

export interface PageCreateInput {
  id?: ID_Input;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaCreateOneInput;
  template?: String;
  blocks?: BlockCreateManyWithoutPageInput;
  boxes?: BoxCreateManyWithoutPageInput;
  prosAndCons?: ProsAndConsCreateManyWithoutPageInput;
  alertBoxes?: AlertBoxCreateManyWithoutPageInput;
  quickTips?: QuickTipCreateManyWithoutPageInput;
  faqs?: PageFaqCreateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionCreateManyWithoutPageInput;
  grids?: GridCreateManyWithoutPageInput;
}

export interface FaqUpdateOneRequiredInput {
  create?: FaqCreateInput;
  update?: FaqUpdateDataInput;
  upsert?: FaqUpsertNestedInput;
  connect?: FaqWhereUniqueInput;
}

export interface MediaUpdateManyMutationInput {
  url?: String;
  title?: String;
  altText?: String;
}

export interface FaqUpdateDataInput {
  title?: String;
  description?: String;
  short_description?: String;
  authors?: UserUpdateManyInput;
  slug?: String;
  vertical?: String;
  category?: FaqCategoryUpdateManyWithoutFaqsInput;
  readingTime?: Int;
  order?: Int;
  variant?: FaqUpdatevariantInput;
  tag?: FaqUpdatetagInput;
  pubDate?: DateTimeInput;
}

export interface GridItemUpdateManyMutationInput {
  title?: String;
  content?: String;
  linkText?: String;
  linkUrl?: String;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface GridUpsertWithoutItemsInput {
  update: GridUpdateWithoutItemsDataInput;
  create: GridCreateWithoutItemsInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface GridUpdateOneWithoutItemsInput {
  create?: GridCreateWithoutItemsInput;
  update?: GridUpdateWithoutItemsDataInput;
  upsert?: GridUpsertWithoutItemsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GridWhereUniqueInput;
}

export interface UserUpdateDataInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserUpdatepermissionsInput;
}

export interface GridItemUpdateInput {
  grid?: GridUpdateOneWithoutItemsInput;
  title?: String;
  content?: String;
  linkText?: String;
  linkUrl?: String;
  media?: MediaUpdateOneInput;
}

export interface UserUpdatepermissionsInput {
  set?: Permission[] | Permission;
}

export interface GridCreateOneWithoutItemsInput {
  create?: GridCreateWithoutItemsInput;
  connect?: GridWhereUniqueInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface GridItemCreateInput {
  id?: ID_Input;
  grid?: GridCreateOneWithoutItemsInput;
  title?: String;
  content?: String;
  linkText?: String;
  linkUrl?: String;
  media?: MediaCreateOneInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  resetToken?: String;
  resetToken_not?: String;
  resetToken_in?: String[] | String;
  resetToken_not_in?: String[] | String;
  resetToken_lt?: String;
  resetToken_lte?: String;
  resetToken_gt?: String;
  resetToken_gte?: String;
  resetToken_contains?: String;
  resetToken_not_contains?: String;
  resetToken_starts_with?: String;
  resetToken_not_starts_with?: String;
  resetToken_ends_with?: String;
  resetToken_not_ends_with?: String;
  resetTokenExpiry?: Float;
  resetTokenExpiry_not?: Float;
  resetTokenExpiry_in?: Float[] | Float;
  resetTokenExpiry_not_in?: Float[] | Float;
  resetTokenExpiry_lt?: Float;
  resetTokenExpiry_lte?: Float;
  resetTokenExpiry_gt?: Float;
  resetTokenExpiry_gte?: Float;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface PageUpsertWithoutGridsInput {
  update: PageUpdateWithoutGridsDataInput;
  create: PageCreateWithoutGridsInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface AlertBoxCreateInput {
  id?: ID_Input;
  page: PageCreateOneWithoutAlertBoxesInput;
  title?: String;
  content?: String;
  prefix?: String;
  style?: String;
  order?: Int;
}

export interface FaqCategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  faqs_every?: FaqWhereInput;
  faqs_some?: FaqWhereInput;
  faqs_none?: FaqWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FaqCategoryWhereInput[] | FaqCategoryWhereInput;
  OR?: FaqCategoryWhereInput[] | FaqCategoryWhereInput;
  NOT?: FaqCategoryWhereInput[] | FaqCategoryWhereInput;
}

export interface PageCreateWithoutAlertBoxesInput {
  id?: ID_Input;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaCreateOneInput;
  template?: String;
  blocks?: BlockCreateManyWithoutPageInput;
  boxes?: BoxCreateManyWithoutPageInput;
  prosAndCons?: ProsAndConsCreateManyWithoutPageInput;
  quickTips?: QuickTipCreateManyWithoutPageInput;
  faqs?: PageFaqCreateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionCreateManyWithoutPageInput;
  grids?: GridCreateManyWithoutPageInput;
}

export interface FaqCategoryUpdateManyWithoutFaqsInput {
  create?:
    | FaqCategoryCreateWithoutFaqsInput[]
    | FaqCategoryCreateWithoutFaqsInput;
  delete?: FaqCategoryWhereUniqueInput[] | FaqCategoryWhereUniqueInput;
  connect?: FaqCategoryWhereUniqueInput[] | FaqCategoryWhereUniqueInput;
  set?: FaqCategoryWhereUniqueInput[] | FaqCategoryWhereUniqueInput;
  disconnect?: FaqCategoryWhereUniqueInput[] | FaqCategoryWhereUniqueInput;
  update?:
    | FaqCategoryUpdateWithWhereUniqueWithoutFaqsInput[]
    | FaqCategoryUpdateWithWhereUniqueWithoutFaqsInput;
  upsert?:
    | FaqCategoryUpsertWithWhereUniqueWithoutFaqsInput[]
    | FaqCategoryUpsertWithWhereUniqueWithoutFaqsInput;
  deleteMany?: FaqCategoryScalarWhereInput[] | FaqCategoryScalarWhereInput;
  updateMany?:
    | FaqCategoryUpdateManyWithWhereNestedInput[]
    | FaqCategoryUpdateManyWithWhereNestedInput;
}

export interface MediaCreateInput {
  id?: ID_Input;
  url: String;
  title?: String;
  altText?: String;
}

export interface FaqCategoryUpdateWithWhereUniqueWithoutFaqsInput {
  where: FaqCategoryWhereUniqueInput;
  data: FaqCategoryUpdateWithoutFaqsDataInput;
}

export interface BlockCreateWithoutPageInput {
  id?: ID_Input;
  title?: String;
  media?: MediaCreateOneInput;
  video?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface FaqCategoryUpdateWithoutFaqsDataInput {
  name?: String;
  slug?: String;
  description?: String;
}

export interface BoxCreateWithoutPageInput {
  id?: ID_Input;
  title?: String;
  media?: MediaCreateOneInput;
  video?: String;
  style?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface FaqCategoryUpsertWithWhereUniqueWithoutFaqsInput {
  where: FaqCategoryWhereUniqueInput;
  update: FaqCategoryUpdateWithoutFaqsDataInput;
  create: FaqCategoryCreateWithoutFaqsInput;
}

export interface ProsAndConsCreateWithoutPageInput {
  id?: ID_Input;
  title?: String;
  order?: Int;
  pros?: ProsCreateManyWithoutProsAndConsInput;
  cons?: ConsCreateManyWithoutProsAndConsInput;
}

export interface FaqCategoryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FaqCategoryScalarWhereInput[] | FaqCategoryScalarWhereInput;
  OR?: FaqCategoryScalarWhereInput[] | FaqCategoryScalarWhereInput;
  NOT?: FaqCategoryScalarWhereInput[] | FaqCategoryScalarWhereInput;
}

export interface ProsCreateWithoutProsAndConsInput {
  id?: ID_Input;
  content?: String;
  order?: Int;
}

export interface FaqCategoryUpdateManyWithWhereNestedInput {
  where: FaqCategoryScalarWhereInput;
  data: FaqCategoryUpdateManyDataInput;
}

export interface ConsCreateWithoutProsAndConsInput {
  id?: ID_Input;
  content?: String;
  order?: Int;
}

export interface FaqCategoryUpdateManyDataInput {
  name?: String;
  slug?: String;
  description?: String;
}

export interface QuickTipCreateWithoutPageInput {
  id?: ID_Input;
  title?: String;
  content?: String;
  buttonText?: String;
  buttonLink?: String;
  media?: MediaCreateOneInput;
  order?: Int;
}

export interface FaqUpdatevariantInput {
  set?: String[] | String;
}

export interface PageFaqCreateWithoutPageInput {
  id?: ID_Input;
  order?: Int;
  faq: FaqCreateOneInput;
}

export interface FaqUpdatetagInput {
  set?: String[] | String;
}

export interface FaqCreateInput {
  id?: ID_Input;
  title: String;
  description?: String;
  short_description?: String;
  authors?: UserCreateManyInput;
  slug: String;
  vertical?: String;
  category?: FaqCategoryCreateManyWithoutFaqsInput;
  readingTime?: Int;
  order?: Int;
  variant?: FaqCreatevariantInput;
  tag?: FaqCreatetagInput;
  pubDate?: DateTimeInput;
}

export interface FaqUpsertNestedInput {
  update: FaqUpdateDataInput;
  create: FaqCreateInput;
}

export interface UserCreateInput {
  id?: ID_Input;
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserCreatepermissionsInput;
}

export interface PageFaqUpsertWithWhereUniqueWithoutPageInput {
  where: PageFaqWhereUniqueInput;
  update: PageFaqUpdateWithoutPageDataInput;
  create: PageFaqCreateWithoutPageInput;
}

export interface FaqCategoryCreateManyWithoutFaqsInput {
  create?:
    | FaqCategoryCreateWithoutFaqsInput[]
    | FaqCategoryCreateWithoutFaqsInput;
  connect?: FaqCategoryWhereUniqueInput[] | FaqCategoryWhereUniqueInput;
}

export interface PageFaqScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  AND?: PageFaqScalarWhereInput[] | PageFaqScalarWhereInput;
  OR?: PageFaqScalarWhereInput[] | PageFaqScalarWhereInput;
  NOT?: PageFaqScalarWhereInput[] | PageFaqScalarWhereInput;
}

export interface FaqCreatevariantInput {
  set?: String[] | String;
}

export interface PageFaqUpdateManyWithWhereNestedInput {
  where: PageFaqScalarWhereInput;
  data: PageFaqUpdateManyDataInput;
}

export interface PageFaqAccordionCreateManyWithoutPageInput {
  create?:
    | PageFaqAccordionCreateWithoutPageInput[]
    | PageFaqAccordionCreateWithoutPageInput;
  connect?:
    | PageFaqAccordionWhereUniqueInput[]
    | PageFaqAccordionWhereUniqueInput;
}

export interface PageFaqUpdateManyDataInput {
  order?: Int;
}

export interface FaqCategoryCreateOneInput {
  create?: FaqCategoryCreateInput;
  connect?: FaqCategoryWhereUniqueInput;
}

export interface PageFaqAccordionUpdateManyWithoutPageInput {
  create?:
    | PageFaqAccordionCreateWithoutPageInput[]
    | PageFaqAccordionCreateWithoutPageInput;
  delete?:
    | PageFaqAccordionWhereUniqueInput[]
    | PageFaqAccordionWhereUniqueInput;
  connect?:
    | PageFaqAccordionWhereUniqueInput[]
    | PageFaqAccordionWhereUniqueInput;
  set?: PageFaqAccordionWhereUniqueInput[] | PageFaqAccordionWhereUniqueInput;
  disconnect?:
    | PageFaqAccordionWhereUniqueInput[]
    | PageFaqAccordionWhereUniqueInput;
  update?:
    | PageFaqAccordionUpdateWithWhereUniqueWithoutPageInput[]
    | PageFaqAccordionUpdateWithWhereUniqueWithoutPageInput;
  upsert?:
    | PageFaqAccordionUpsertWithWhereUniqueWithoutPageInput[]
    | PageFaqAccordionUpsertWithWhereUniqueWithoutPageInput;
  deleteMany?:
    | PageFaqAccordionScalarWhereInput[]
    | PageFaqAccordionScalarWhereInput;
  updateMany?:
    | PageFaqAccordionUpdateManyWithWhereNestedInput[]
    | PageFaqAccordionUpdateManyWithWhereNestedInput;
}

export interface FaqCreateManyWithoutCategoryInput {
  create?: FaqCreateWithoutCategoryInput[] | FaqCreateWithoutCategoryInput;
  connect?: FaqWhereUniqueInput[] | FaqWhereUniqueInput;
}

export interface PageFaqAccordionUpdateWithWhereUniqueWithoutPageInput {
  where: PageFaqAccordionWhereUniqueInput;
  data: PageFaqAccordionUpdateWithoutPageDataInput;
}

export interface GridCreateManyWithoutPageInput {
  create?: GridCreateWithoutPageInput[] | GridCreateWithoutPageInput;
  connect?: GridWhereUniqueInput[] | GridWhereUniqueInput;
}

export interface PageFaqAccordionUpdateWithoutPageDataInput {
  order?: Int;
  faqCategory?: FaqCategoryUpdateOneRequiredInput;
}

export interface GridItemCreateManyWithoutGridInput {
  create?: GridItemCreateWithoutGridInput[] | GridItemCreateWithoutGridInput;
  connect?: GridItemWhereUniqueInput[] | GridItemWhereUniqueInput;
}

export interface FaqCategoryUpdateOneRequiredInput {
  create?: FaqCategoryCreateInput;
  update?: FaqCategoryUpdateDataInput;
  upsert?: FaqCategoryUpsertNestedInput;
  connect?: FaqCategoryWhereUniqueInput;
}

export interface AlertBoxUpdateInput {
  page?: PageUpdateOneRequiredWithoutAlertBoxesInput;
  title?: String;
  content?: String;
  prefix?: String;
  style?: String;
  order?: Int;
}

export interface FaqCategoryUpdateDataInput {
  name?: String;
  slug?: String;
  description?: String;
  faqs?: FaqUpdateManyWithoutCategoryInput;
}

export interface PageUpdateWithoutAlertBoxesDataInput {
  title?: String;
  slug?: String;
  url?: String;
  type?: PageType;
  status?: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaUpdateOneInput;
  template?: String;
  blocks?: BlockUpdateManyWithoutPageInput;
  boxes?: BoxUpdateManyWithoutPageInput;
  prosAndCons?: ProsAndConsUpdateManyWithoutPageInput;
  quickTips?: QuickTipUpdateManyWithoutPageInput;
  faqs?: PageFaqUpdateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionUpdateManyWithoutPageInput;
  grids?: GridUpdateManyWithoutPageInput;
}

export interface FaqUpdateManyWithoutCategoryInput {
  create?: FaqCreateWithoutCategoryInput[] | FaqCreateWithoutCategoryInput;
  delete?: FaqWhereUniqueInput[] | FaqWhereUniqueInput;
  connect?: FaqWhereUniqueInput[] | FaqWhereUniqueInput;
  set?: FaqWhereUniqueInput[] | FaqWhereUniqueInput;
  disconnect?: FaqWhereUniqueInput[] | FaqWhereUniqueInput;
  update?:
    | FaqUpdateWithWhereUniqueWithoutCategoryInput[]
    | FaqUpdateWithWhereUniqueWithoutCategoryInput;
  upsert?:
    | FaqUpsertWithWhereUniqueWithoutCategoryInput[]
    | FaqUpsertWithWhereUniqueWithoutCategoryInput;
  deleteMany?: FaqScalarWhereInput[] | FaqScalarWhereInput;
  updateMany?:
    | FaqUpdateManyWithWhereNestedInput[]
    | FaqUpdateManyWithWhereNestedInput;
}

export interface MediaUpdateDataInput {
  url?: String;
  title?: String;
  altText?: String;
}

export interface FaqUpdateWithWhereUniqueWithoutCategoryInput {
  where: FaqWhereUniqueInput;
  data: FaqUpdateWithoutCategoryDataInput;
}

export interface BlockUpdateManyWithoutPageInput {
  create?: BlockCreateWithoutPageInput[] | BlockCreateWithoutPageInput;
  delete?: BlockWhereUniqueInput[] | BlockWhereUniqueInput;
  connect?: BlockWhereUniqueInput[] | BlockWhereUniqueInput;
  set?: BlockWhereUniqueInput[] | BlockWhereUniqueInput;
  disconnect?: BlockWhereUniqueInput[] | BlockWhereUniqueInput;
  update?:
    | BlockUpdateWithWhereUniqueWithoutPageInput[]
    | BlockUpdateWithWhereUniqueWithoutPageInput;
  upsert?:
    | BlockUpsertWithWhereUniqueWithoutPageInput[]
    | BlockUpsertWithWhereUniqueWithoutPageInput;
  deleteMany?: BlockScalarWhereInput[] | BlockScalarWhereInput;
  updateMany?:
    | BlockUpdateManyWithWhereNestedInput[]
    | BlockUpdateManyWithWhereNestedInput;
}

export interface FaqUpdateWithoutCategoryDataInput {
  title?: String;
  description?: String;
  short_description?: String;
  authors?: UserUpdateManyInput;
  slug?: String;
  vertical?: String;
  readingTime?: Int;
  order?: Int;
  variant?: FaqUpdatevariantInput;
  tag?: FaqUpdatetagInput;
  pubDate?: DateTimeInput;
}

export interface PageFaqAccordionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  page?: PageWhereInput;
  faqCategory?: FaqCategoryWhereInput;
  AND?: PageFaqAccordionWhereInput[] | PageFaqAccordionWhereInput;
  OR?: PageFaqAccordionWhereInput[] | PageFaqAccordionWhereInput;
  NOT?: PageFaqAccordionWhereInput[] | PageFaqAccordionWhereInput;
}

export interface FaqUpsertWithWhereUniqueWithoutCategoryInput {
  where: FaqWhereUniqueInput;
  update: FaqUpdateWithoutCategoryDataInput;
  create: FaqCreateWithoutCategoryInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface FaqScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  short_description?: String;
  short_description_not?: String;
  short_description_in?: String[] | String;
  short_description_not_in?: String[] | String;
  short_description_lt?: String;
  short_description_lte?: String;
  short_description_gt?: String;
  short_description_gte?: String;
  short_description_contains?: String;
  short_description_not_contains?: String;
  short_description_starts_with?: String;
  short_description_not_starts_with?: String;
  short_description_ends_with?: String;
  short_description_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  vertical?: String;
  vertical_not?: String;
  vertical_in?: String[] | String;
  vertical_not_in?: String[] | String;
  vertical_lt?: String;
  vertical_lte?: String;
  vertical_gt?: String;
  vertical_gte?: String;
  vertical_contains?: String;
  vertical_not_contains?: String;
  vertical_starts_with?: String;
  vertical_not_starts_with?: String;
  vertical_ends_with?: String;
  vertical_not_ends_with?: String;
  readingTime?: Int;
  readingTime_not?: Int;
  readingTime_in?: Int[] | Int;
  readingTime_not_in?: Int[] | Int;
  readingTime_lt?: Int;
  readingTime_lte?: Int;
  readingTime_gt?: Int;
  readingTime_gte?: Int;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  pubDate?: DateTimeInput;
  pubDate_not?: DateTimeInput;
  pubDate_in?: DateTimeInput[] | DateTimeInput;
  pubDate_not_in?: DateTimeInput[] | DateTimeInput;
  pubDate_lt?: DateTimeInput;
  pubDate_lte?: DateTimeInput;
  pubDate_gt?: DateTimeInput;
  pubDate_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FaqScalarWhereInput[] | FaqScalarWhereInput;
  OR?: FaqScalarWhereInput[] | FaqScalarWhereInput;
  NOT?: FaqScalarWhereInput[] | FaqScalarWhereInput;
}

export interface ProsAndConsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProsAndConsWhereInput;
  AND?: ProsAndConsSubscriptionWhereInput[] | ProsAndConsSubscriptionWhereInput;
  OR?: ProsAndConsSubscriptionWhereInput[] | ProsAndConsSubscriptionWhereInput;
  NOT?: ProsAndConsSubscriptionWhereInput[] | ProsAndConsSubscriptionWhereInput;
}

export interface FaqUpdateManyWithWhereNestedInput {
  where: FaqScalarWhereInput;
  data: FaqUpdateManyDataInput;
}

export interface PageFaqAccordionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PageFaqAccordionWhereInput;
  AND?:
    | PageFaqAccordionSubscriptionWhereInput[]
    | PageFaqAccordionSubscriptionWhereInput;
  OR?:
    | PageFaqAccordionSubscriptionWhereInput[]
    | PageFaqAccordionSubscriptionWhereInput;
  NOT?:
    | PageFaqAccordionSubscriptionWhereInput[]
    | PageFaqAccordionSubscriptionWhereInput;
}

export interface FaqUpdateManyDataInput {
  title?: String;
  description?: String;
  short_description?: String;
  slug?: String;
  vertical?: String;
  readingTime?: Int;
  order?: Int;
  variant?: FaqUpdatevariantInput;
  tag?: FaqUpdatetagInput;
  pubDate?: DateTimeInput;
}

export interface ProsAndConsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  page?: PageWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  pros_every?: ProsWhereInput;
  pros_some?: ProsWhereInput;
  pros_none?: ProsWhereInput;
  cons_every?: ConsWhereInput;
  cons_some?: ConsWhereInput;
  cons_none?: ConsWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProsAndConsWhereInput[] | ProsAndConsWhereInput;
  OR?: ProsAndConsWhereInput[] | ProsAndConsWhereInput;
  NOT?: ProsAndConsWhereInput[] | ProsAndConsWhereInput;
}

export interface FaqCategoryUpsertNestedInput {
  update: FaqCategoryUpdateDataInput;
  create: FaqCategoryCreateInput;
}

export interface GridSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GridWhereInput;
  AND?: GridSubscriptionWhereInput[] | GridSubscriptionWhereInput;
  OR?: GridSubscriptionWhereInput[] | GridSubscriptionWhereInput;
  NOT?: GridSubscriptionWhereInput[] | GridSubscriptionWhereInput;
}

export interface PageFaqAccordionUpsertWithWhereUniqueWithoutPageInput {
  where: PageFaqAccordionWhereUniqueInput;
  update: PageFaqAccordionUpdateWithoutPageDataInput;
  create: PageFaqAccordionCreateWithoutPageInput;
}

export interface PageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  type?: PageType;
  type_not?: PageType;
  type_in?: PageType[] | PageType;
  type_not_in?: PageType[] | PageType;
  status?: PageStatus;
  status_not?: PageStatus;
  status_in?: PageStatus[] | PageStatus;
  status_not_in?: PageStatus[] | PageStatus;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  vertical?: String;
  vertical_not?: String;
  vertical_in?: String[] | String;
  vertical_not_in?: String[] | String;
  vertical_lt?: String;
  vertical_lte?: String;
  vertical_gt?: String;
  vertical_gte?: String;
  vertical_contains?: String;
  vertical_not_contains?: String;
  vertical_starts_with?: String;
  vertical_not_starts_with?: String;
  vertical_ends_with?: String;
  vertical_not_ends_with?: String;
  media?: MediaWhereInput;
  template?: String;
  template_not?: String;
  template_in?: String[] | String;
  template_not_in?: String[] | String;
  template_lt?: String;
  template_lte?: String;
  template_gt?: String;
  template_gte?: String;
  template_contains?: String;
  template_not_contains?: String;
  template_starts_with?: String;
  template_not_starts_with?: String;
  template_ends_with?: String;
  template_not_ends_with?: String;
  blocks_every?: BlockWhereInput;
  blocks_some?: BlockWhereInput;
  blocks_none?: BlockWhereInput;
  boxes_every?: BoxWhereInput;
  boxes_some?: BoxWhereInput;
  boxes_none?: BoxWhereInput;
  prosAndCons_every?: ProsAndConsWhereInput;
  prosAndCons_some?: ProsAndConsWhereInput;
  prosAndCons_none?: ProsAndConsWhereInput;
  alertBoxes_every?: AlertBoxWhereInput;
  alertBoxes_some?: AlertBoxWhereInput;
  alertBoxes_none?: AlertBoxWhereInput;
  quickTips_every?: QuickTipWhereInput;
  quickTips_some?: QuickTipWhereInput;
  quickTips_none?: QuickTipWhereInput;
  faqs_every?: PageFaqWhereInput;
  faqs_some?: PageFaqWhereInput;
  faqs_none?: PageFaqWhereInput;
  faqAccordion_every?: PageFaqAccordionWhereInput;
  faqAccordion_some?: PageFaqAccordionWhereInput;
  faqAccordion_none?: PageFaqAccordionWhereInput;
  grids_every?: GridWhereInput;
  grids_some?: GridWhereInput;
  grids_none?: GridWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PageWhereInput[] | PageWhereInput;
  OR?: PageWhereInput[] | PageWhereInput;
  NOT?: PageWhereInput[] | PageWhereInput;
}

export interface PageFaqAccordionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  AND?: PageFaqAccordionScalarWhereInput[] | PageFaqAccordionScalarWhereInput;
  OR?: PageFaqAccordionScalarWhereInput[] | PageFaqAccordionScalarWhereInput;
  NOT?: PageFaqAccordionScalarWhereInput[] | PageFaqAccordionScalarWhereInput;
}

export interface BoxSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BoxWhereInput;
  AND?: BoxSubscriptionWhereInput[] | BoxSubscriptionWhereInput;
  OR?: BoxSubscriptionWhereInput[] | BoxSubscriptionWhereInput;
  NOT?: BoxSubscriptionWhereInput[] | BoxSubscriptionWhereInput;
}

export interface PageFaqAccordionUpdateManyWithWhereNestedInput {
  where: PageFaqAccordionScalarWhereInput;
  data: PageFaqAccordionUpdateManyDataInput;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserUpdatepermissionsInput;
}

export interface PageFaqAccordionUpdateManyDataInput {
  order?: Int;
}

export type BlockWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GridUpdateManyWithoutPageInput {
  create?: GridCreateWithoutPageInput[] | GridCreateWithoutPageInput;
  delete?: GridWhereUniqueInput[] | GridWhereUniqueInput;
  connect?: GridWhereUniqueInput[] | GridWhereUniqueInput;
  set?: GridWhereUniqueInput[] | GridWhereUniqueInput;
  disconnect?: GridWhereUniqueInput[] | GridWhereUniqueInput;
  update?:
    | GridUpdateWithWhereUniqueWithoutPageInput[]
    | GridUpdateWithWhereUniqueWithoutPageInput;
  upsert?:
    | GridUpsertWithWhereUniqueWithoutPageInput[]
    | GridUpsertWithWhereUniqueWithoutPageInput;
  deleteMany?: GridScalarWhereInput[] | GridScalarWhereInput;
  updateMany?:
    | GridUpdateManyWithWhereNestedInput[]
    | GridUpdateManyWithWhereNestedInput;
}

export type BoxWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GridUpdateWithWhereUniqueWithoutPageInput {
  where: GridWhereUniqueInput;
  data: GridUpdateWithoutPageDataInput;
}

export type ConsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GridUpdateWithoutPageDataInput {
  title?: String;
  media?: MediaUpdateOneInput;
  content?: String;
  order?: Int;
  items?: GridItemUpdateManyWithoutGridInput;
}

export type FaqWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GridItemUpdateManyWithoutGridInput {
  create?: GridItemCreateWithoutGridInput[] | GridItemCreateWithoutGridInput;
  delete?: GridItemWhereUniqueInput[] | GridItemWhereUniqueInput;
  connect?: GridItemWhereUniqueInput[] | GridItemWhereUniqueInput;
  set?: GridItemWhereUniqueInput[] | GridItemWhereUniqueInput;
  disconnect?: GridItemWhereUniqueInput[] | GridItemWhereUniqueInput;
  update?:
    | GridItemUpdateWithWhereUniqueWithoutGridInput[]
    | GridItemUpdateWithWhereUniqueWithoutGridInput;
  upsert?:
    | GridItemUpsertWithWhereUniqueWithoutGridInput[]
    | GridItemUpsertWithWhereUniqueWithoutGridInput;
  deleteMany?: GridItemScalarWhereInput[] | GridItemScalarWhereInput;
  updateMany?:
    | GridItemUpdateManyWithWhereNestedInput[]
    | GridItemUpdateManyWithWhereNestedInput;
}

export type FaqCategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GridItemUpdateWithWhereUniqueWithoutGridInput {
  where: GridItemWhereUniqueInput;
  data: GridItemUpdateWithoutGridDataInput;
}

export type GridWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GridItemUpdateWithoutGridDataInput {
  title?: String;
  content?: String;
  linkText?: String;
  linkUrl?: String;
  media?: MediaUpdateOneInput;
}

export type GridItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GridItemUpsertWithWhereUniqueWithoutGridInput {
  where: GridItemWhereUniqueInput;
  update: GridItemUpdateWithoutGridDataInput;
  create: GridItemCreateWithoutGridInput;
}

export type MediaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GridItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  linkText?: String;
  linkText_not?: String;
  linkText_in?: String[] | String;
  linkText_not_in?: String[] | String;
  linkText_lt?: String;
  linkText_lte?: String;
  linkText_gt?: String;
  linkText_gte?: String;
  linkText_contains?: String;
  linkText_not_contains?: String;
  linkText_starts_with?: String;
  linkText_not_starts_with?: String;
  linkText_ends_with?: String;
  linkText_not_ends_with?: String;
  linkUrl?: String;
  linkUrl_not?: String;
  linkUrl_in?: String[] | String;
  linkUrl_not_in?: String[] | String;
  linkUrl_lt?: String;
  linkUrl_lte?: String;
  linkUrl_gt?: String;
  linkUrl_gte?: String;
  linkUrl_contains?: String;
  linkUrl_not_contains?: String;
  linkUrl_starts_with?: String;
  linkUrl_not_starts_with?: String;
  linkUrl_ends_with?: String;
  linkUrl_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: GridItemScalarWhereInput[] | GridItemScalarWhereInput;
  OR?: GridItemScalarWhereInput[] | GridItemScalarWhereInput;
  NOT?: GridItemScalarWhereInput[] | GridItemScalarWhereInput;
}

export interface PageFaqUpdateManyMutationInput {
  order?: Int;
}

export interface GridItemUpdateManyWithWhereNestedInput {
  where: GridItemScalarWhereInput;
  data: GridItemUpdateManyDataInput;
}

export interface PageUpdateOneRequiredWithoutFaqsInput {
  create?: PageCreateWithoutFaqsInput;
  update?: PageUpdateWithoutFaqsDataInput;
  upsert?: PageUpsertWithoutFaqsInput;
  connect?: PageWhereUniqueInput;
}

export interface GridItemUpdateManyDataInput {
  title?: String;
  content?: String;
  linkText?: String;
  linkUrl?: String;
}

export interface PageCreateOneWithoutFaqsInput {
  create?: PageCreateWithoutFaqsInput;
  connect?: PageWhereUniqueInput;
}

export interface GridUpsertWithWhereUniqueWithoutPageInput {
  where: GridWhereUniqueInput;
  update: GridUpdateWithoutPageDataInput;
  create: GridCreateWithoutPageInput;
}

export interface PageUpdateInput {
  title?: String;
  slug?: String;
  url?: String;
  type?: PageType;
  status?: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaUpdateOneInput;
  template?: String;
  blocks?: BlockUpdateManyWithoutPageInput;
  boxes?: BoxUpdateManyWithoutPageInput;
  prosAndCons?: ProsAndConsUpdateManyWithoutPageInput;
  alertBoxes?: AlertBoxUpdateManyWithoutPageInput;
  quickTips?: QuickTipUpdateManyWithoutPageInput;
  faqs?: PageFaqUpdateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionUpdateManyWithoutPageInput;
  grids?: GridUpdateManyWithoutPageInput;
}

export interface GridScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: GridScalarWhereInput[] | GridScalarWhereInput;
  OR?: GridScalarWhereInput[] | GridScalarWhereInput;
  NOT?: GridScalarWhereInput[] | GridScalarWhereInput;
}

export interface MediaUpdateInput {
  url?: String;
  title?: String;
  altText?: String;
}

export interface GridUpdateManyWithWhereNestedInput {
  where: GridScalarWhereInput;
  data: GridUpdateManyDataInput;
}

export interface GridUpdateWithoutItemsDataInput {
  title?: String;
  page?: PageUpdateOneRequiredWithoutGridsInput;
  media?: MediaUpdateOneInput;
  content?: String;
  order?: Int;
}

export interface GridUpdateManyDataInput {
  title?: String;
  content?: String;
  order?: Int;
}

export interface GridCreateWithoutItemsInput {
  id?: ID_Input;
  title?: String;
  page: PageCreateOneWithoutGridsInput;
  media?: MediaCreateOneInput;
  content?: String;
  order?: Int;
}

export interface PageUpsertWithoutAlertBoxesInput {
  update: PageUpdateWithoutAlertBoxesDataInput;
  create: PageCreateWithoutAlertBoxesInput;
}

export interface GridUpdateManyMutationInput {
  title?: String;
  content?: String;
  order?: Int;
}

export interface AlertBoxUpdateManyMutationInput {
  title?: String;
  content?: String;
  prefix?: String;
  style?: String;
  order?: Int;
}

export interface PageCreateOneWithoutAlertBoxesInput {
  create?: PageCreateWithoutAlertBoxesInput;
  connect?: PageWhereUniqueInput;
}

export interface PageUpdateOneRequiredWithoutGridsInput {
  create?: PageCreateWithoutGridsInput;
  update?: PageUpdateWithoutGridsDataInput;
  upsert?: PageUpsertWithoutGridsInput;
  connect?: PageWhereUniqueInput;
}

export interface BlockCreateManyWithoutPageInput {
  create?: BlockCreateWithoutPageInput[] | BlockCreateWithoutPageInput;
  connect?: BlockWhereUniqueInput[] | BlockWhereUniqueInput;
}

export interface GridUpdateInput {
  title?: String;
  page?: PageUpdateOneRequiredWithoutGridsInput;
  media?: MediaUpdateOneInput;
  content?: String;
  order?: Int;
  items?: GridItemUpdateManyWithoutGridInput;
}

export interface ProsAndConsCreateManyWithoutPageInput {
  create?:
    | ProsAndConsCreateWithoutPageInput[]
    | ProsAndConsCreateWithoutPageInput;
  connect?: ProsAndConsWhereUniqueInput[] | ProsAndConsWhereUniqueInput;
}

export interface BlockCreateInput {
  id?: ID_Input;
  page: PageCreateOneWithoutBlocksInput;
  title?: String;
  media?: MediaCreateOneInput;
  video?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface ConsCreateManyWithoutProsAndConsInput {
  create?:
    | ConsCreateWithoutProsAndConsInput[]
    | ConsCreateWithoutProsAndConsInput;
  connect?: ConsWhereUniqueInput[] | ConsWhereUniqueInput;
}

export interface PageCreateOneWithoutBlocksInput {
  create?: PageCreateWithoutBlocksInput;
  connect?: PageWhereUniqueInput;
}

export interface PageFaqCreateManyWithoutPageInput {
  create?: PageFaqCreateWithoutPageInput[] | PageFaqCreateWithoutPageInput;
  connect?: PageFaqWhereUniqueInput[] | PageFaqWhereUniqueInput;
}

export interface PageCreateWithoutBlocksInput {
  id?: ID_Input;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaCreateOneInput;
  template?: String;
  boxes?: BoxCreateManyWithoutPageInput;
  prosAndCons?: ProsAndConsCreateManyWithoutPageInput;
  alertBoxes?: AlertBoxCreateManyWithoutPageInput;
  quickTips?: QuickTipCreateManyWithoutPageInput;
  faqs?: PageFaqCreateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionCreateManyWithoutPageInput;
  grids?: GridCreateManyWithoutPageInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface AlertBoxCreateManyWithoutPageInput {
  create?: AlertBoxCreateWithoutPageInput[] | AlertBoxCreateWithoutPageInput;
  connect?: AlertBoxWhereUniqueInput[] | AlertBoxWhereUniqueInput;
}

export interface FaqCategoryCreateWithoutFaqsInput {
  id?: ID_Input;
  name: String;
  slug: String;
  description: String;
}

export interface AlertBoxCreateWithoutPageInput {
  id?: ID_Input;
  title?: String;
  content?: String;
  prefix?: String;
  style?: String;
  order?: Int;
}

export interface PageFaqAccordionCreateWithoutPageInput {
  id?: ID_Input;
  order?: Int;
  faqCategory: FaqCategoryCreateOneInput;
}

export interface BlockUpdateInput {
  page?: PageUpdateOneRequiredWithoutBlocksInput;
  title?: String;
  media?: MediaUpdateOneInput;
  video?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface FaqCreateWithoutCategoryInput {
  id?: ID_Input;
  title: String;
  description?: String;
  short_description?: String;
  authors?: UserCreateManyInput;
  slug: String;
  vertical?: String;
  readingTime?: Int;
  order?: Int;
  variant?: FaqCreatevariantInput;
  tag?: FaqCreatetagInput;
  pubDate?: DateTimeInput;
}

export interface PageUpdateOneRequiredWithoutBlocksInput {
  create?: PageCreateWithoutBlocksInput;
  update?: PageUpdateWithoutBlocksDataInput;
  upsert?: PageUpsertWithoutBlocksInput;
  connect?: PageWhereUniqueInput;
}

export interface GridItemCreateWithoutGridInput {
  id?: ID_Input;
  title?: String;
  content?: String;
  linkText?: String;
  linkUrl?: String;
  media?: MediaCreateOneInput;
}

export interface PageUpdateWithoutBlocksDataInput {
  title?: String;
  slug?: String;
  url?: String;
  type?: PageType;
  status?: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaUpdateOneInput;
  template?: String;
  boxes?: BoxUpdateManyWithoutPageInput;
  prosAndCons?: ProsAndConsUpdateManyWithoutPageInput;
  alertBoxes?: AlertBoxUpdateManyWithoutPageInput;
  quickTips?: QuickTipUpdateManyWithoutPageInput;
  faqs?: PageFaqUpdateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionUpdateManyWithoutPageInput;
  grids?: GridUpdateManyWithoutPageInput;
}

export interface MediaUpdateOneInput {
  create?: MediaCreateInput;
  update?: MediaUpdateDataInput;
  upsert?: MediaUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MediaWhereUniqueInput;
}

export interface AlertBoxUpdateManyWithoutPageInput {
  create?: AlertBoxCreateWithoutPageInput[] | AlertBoxCreateWithoutPageInput;
  delete?: AlertBoxWhereUniqueInput[] | AlertBoxWhereUniqueInput;
  connect?: AlertBoxWhereUniqueInput[] | AlertBoxWhereUniqueInput;
  set?: AlertBoxWhereUniqueInput[] | AlertBoxWhereUniqueInput;
  disconnect?: AlertBoxWhereUniqueInput[] | AlertBoxWhereUniqueInput;
  update?:
    | AlertBoxUpdateWithWhereUniqueWithoutPageInput[]
    | AlertBoxUpdateWithWhereUniqueWithoutPageInput;
  upsert?:
    | AlertBoxUpsertWithWhereUniqueWithoutPageInput[]
    | AlertBoxUpsertWithWhereUniqueWithoutPageInput;
  deleteMany?: AlertBoxScalarWhereInput[] | AlertBoxScalarWhereInput;
  updateMany?:
    | AlertBoxUpdateManyWithWhereNestedInput[]
    | AlertBoxUpdateManyWithWhereNestedInput;
}

export interface BlockUpdateWithWhereUniqueWithoutPageInput {
  where: BlockWhereUniqueInput;
  data: BlockUpdateWithoutPageDataInput;
}

export interface AlertBoxUpdateWithWhereUniqueWithoutPageInput {
  where: AlertBoxWhereUniqueInput;
  data: AlertBoxUpdateWithoutPageDataInput;
}

export interface QuickTipSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: QuickTipWhereInput;
  AND?: QuickTipSubscriptionWhereInput[] | QuickTipSubscriptionWhereInput;
  OR?: QuickTipSubscriptionWhereInput[] | QuickTipSubscriptionWhereInput;
  NOT?: QuickTipSubscriptionWhereInput[] | QuickTipSubscriptionWhereInput;
}

export interface AlertBoxUpdateWithoutPageDataInput {
  title?: String;
  content?: String;
  prefix?: String;
  style?: String;
  order?: Int;
}

export interface ProsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  prosAndCons?: ProsAndConsWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProsWhereInput[] | ProsWhereInput;
  OR?: ProsWhereInput[] | ProsWhereInput;
  NOT?: ProsWhereInput[] | ProsWhereInput;
}

export interface AlertBoxUpsertWithWhereUniqueWithoutPageInput {
  where: AlertBoxWhereUniqueInput;
  update: AlertBoxUpdateWithoutPageDataInput;
  create: AlertBoxCreateWithoutPageInput;
}

export interface MediaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  altText?: String;
  altText_not?: String;
  altText_in?: String[] | String;
  altText_not_in?: String[] | String;
  altText_lt?: String;
  altText_lte?: String;
  altText_gt?: String;
  altText_gte?: String;
  altText_contains?: String;
  altText_not_contains?: String;
  altText_starts_with?: String;
  altText_not_starts_with?: String;
  altText_ends_with?: String;
  altText_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MediaWhereInput[] | MediaWhereInput;
  OR?: MediaWhereInput[] | MediaWhereInput;
  NOT?: MediaWhereInput[] | MediaWhereInput;
}

export interface AlertBoxScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  prefix?: String;
  prefix_not?: String;
  prefix_in?: String[] | String;
  prefix_not_in?: String[] | String;
  prefix_lt?: String;
  prefix_lte?: String;
  prefix_gt?: String;
  prefix_gte?: String;
  prefix_contains?: String;
  prefix_not_contains?: String;
  prefix_starts_with?: String;
  prefix_not_starts_with?: String;
  prefix_ends_with?: String;
  prefix_not_ends_with?: String;
  style?: String;
  style_not?: String;
  style_in?: String[] | String;
  style_not_in?: String[] | String;
  style_lt?: String;
  style_lte?: String;
  style_gt?: String;
  style_gte?: String;
  style_contains?: String;
  style_not_contains?: String;
  style_starts_with?: String;
  style_not_starts_with?: String;
  style_ends_with?: String;
  style_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AlertBoxScalarWhereInput[] | AlertBoxScalarWhereInput;
  OR?: AlertBoxScalarWhereInput[] | AlertBoxScalarWhereInput;
  NOT?: AlertBoxScalarWhereInput[] | AlertBoxScalarWhereInput;
}

export interface AlertBoxSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AlertBoxWhereInput;
  AND?: AlertBoxSubscriptionWhereInput[] | AlertBoxSubscriptionWhereInput;
  OR?: AlertBoxSubscriptionWhereInput[] | AlertBoxSubscriptionWhereInput;
  NOT?: AlertBoxSubscriptionWhereInput[] | AlertBoxSubscriptionWhereInput;
}

export interface AlertBoxUpdateManyWithWhereNestedInput {
  where: AlertBoxScalarWhereInput;
  data: AlertBoxUpdateManyDataInput;
}

export interface QuickTipUpdateInput {
  page?: PageUpdateOneRequiredWithoutQuickTipsInput;
  title?: String;
  content?: String;
  buttonText?: String;
  buttonLink?: String;
  media?: MediaUpdateOneInput;
  order?: Int;
}

export interface AlertBoxUpdateManyDataInput {
  title?: String;
  content?: String;
  prefix?: String;
  style?: String;
  order?: Int;
}

export interface ProsAndConsCreateInput {
  id?: ID_Input;
  page: PageCreateOneWithoutProsAndConsInput;
  title?: String;
  order?: Int;
  pros?: ProsCreateManyWithoutProsAndConsInput;
  cons?: ConsCreateManyWithoutProsAndConsInput;
}

export interface PageUpsertWithoutBlocksInput {
  update: PageUpdateWithoutBlocksDataInput;
  create: PageCreateWithoutBlocksInput;
}

export interface ProsAndConsCreateWithoutProsInput {
  id?: ID_Input;
  page: PageCreateOneWithoutProsAndConsInput;
  title?: String;
  order?: Int;
  cons?: ConsCreateManyWithoutProsAndConsInput;
}

export interface BlockUpdateManyMutationInput {
  title?: String;
  video?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface PageUpdateOneRequiredWithoutFaqAccordionInput {
  create?: PageCreateWithoutFaqAccordionInput;
  update?: PageUpdateWithoutFaqAccordionDataInput;
  upsert?: PageUpsertWithoutFaqAccordionInput;
  connect?: PageWhereUniqueInput;
}

export interface BoxCreateInput {
  id?: ID_Input;
  page: PageCreateOneWithoutBoxesInput;
  title?: String;
  media?: MediaCreateOneInput;
  video?: String;
  style?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface PageUpsertWithoutFaqsInput {
  update: PageUpdateWithoutFaqsDataInput;
  create: PageCreateWithoutFaqsInput;
}

export interface PageCreateOneWithoutBoxesInput {
  create?: PageCreateWithoutBoxesInput;
  connect?: PageWhereUniqueInput;
}

export type PageFaqAccordionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PageCreateWithoutBoxesInput {
  id?: ID_Input;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaCreateOneInput;
  template?: String;
  blocks?: BlockCreateManyWithoutPageInput;
  prosAndCons?: ProsAndConsCreateManyWithoutPageInput;
  alertBoxes?: AlertBoxCreateManyWithoutPageInput;
  quickTips?: QuickTipCreateManyWithoutPageInput;
  faqs?: PageFaqCreateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionCreateManyWithoutPageInput;
  grids?: GridCreateManyWithoutPageInput;
}

export type ProsAndConsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BoxUpdateInput {
  page?: PageUpdateOneRequiredWithoutBoxesInput;
  title?: String;
  media?: MediaUpdateOneInput;
  video?: String;
  style?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface PageUpdateOneRequiredWithoutBoxesInput {
  create?: PageCreateWithoutBoxesInput;
  update?: PageUpdateWithoutBoxesDataInput;
  upsert?: PageUpsertWithoutBoxesInput;
  connect?: PageWhereUniqueInput;
}

export interface MediaCreateOneInput {
  create?: MediaCreateInput;
  connect?: MediaWhereUniqueInput;
}

export interface PageUpdateWithoutBoxesDataInput {
  title?: String;
  slug?: String;
  url?: String;
  type?: PageType;
  status?: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaUpdateOneInput;
  template?: String;
  blocks?: BlockUpdateManyWithoutPageInput;
  prosAndCons?: ProsAndConsUpdateManyWithoutPageInput;
  alertBoxes?: AlertBoxUpdateManyWithoutPageInput;
  quickTips?: QuickTipUpdateManyWithoutPageInput;
  faqs?: PageFaqUpdateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionUpdateManyWithoutPageInput;
  grids?: GridUpdateManyWithoutPageInput;
}

export interface ProsCreateManyWithoutProsAndConsInput {
  create?:
    | ProsCreateWithoutProsAndConsInput[]
    | ProsCreateWithoutProsAndConsInput;
  connect?: ProsWhereUniqueInput[] | ProsWhereUniqueInput;
}

export interface PageUpsertWithoutBoxesInput {
  update: PageUpdateWithoutBoxesDataInput;
  create: PageCreateWithoutBoxesInput;
}

export interface FaqCreateOneInput {
  create?: FaqCreateInput;
  connect?: FaqWhereUniqueInput;
}

export interface BoxUpdateManyMutationInput {
  title?: String;
  video?: String;
  style?: String;
  alignment?: String;
  content?: String;
  order?: Int;
}

export interface FaqCreatetagInput {
  set?: String[] | String;
}

export interface ConsCreateInput {
  id?: ID_Input;
  prosAndCons: ProsAndConsCreateOneWithoutConsInput;
  content?: String;
  order?: Int;
}

export interface GridCreateWithoutPageInput {
  id?: ID_Input;
  title?: String;
  media?: MediaCreateOneInput;
  content?: String;
  order?: Int;
  items?: GridItemCreateManyWithoutGridInput;
}

export interface ProsAndConsCreateOneWithoutConsInput {
  create?: ProsAndConsCreateWithoutConsInput;
  connect?: ProsAndConsWhereUniqueInput;
}

export interface MediaUpsertNestedInput {
  update: MediaUpdateDataInput;
  create: MediaCreateInput;
}

export interface ProsAndConsCreateWithoutConsInput {
  id?: ID_Input;
  page: PageCreateOneWithoutProsAndConsInput;
  title?: String;
  order?: Int;
  pros?: ProsCreateManyWithoutProsAndConsInput;
}

export interface ProsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProsWhereInput;
  AND?: ProsSubscriptionWhereInput[] | ProsSubscriptionWhereInput;
  OR?: ProsSubscriptionWhereInput[] | ProsSubscriptionWhereInput;
  NOT?: ProsSubscriptionWhereInput[] | ProsSubscriptionWhereInput;
}

export interface PageCreateOneWithoutProsAndConsInput {
  create?: PageCreateWithoutProsAndConsInput;
  connect?: PageWhereUniqueInput;
}

export interface FaqSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FaqWhereInput;
  AND?: FaqSubscriptionWhereInput[] | FaqSubscriptionWhereInput;
  OR?: FaqSubscriptionWhereInput[] | FaqSubscriptionWhereInput;
  NOT?: FaqSubscriptionWhereInput[] | FaqSubscriptionWhereInput;
}

export interface PageCreateWithoutProsAndConsInput {
  id?: ID_Input;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaCreateOneInput;
  template?: String;
  blocks?: BlockCreateManyWithoutPageInput;
  boxes?: BoxCreateManyWithoutPageInput;
  alertBoxes?: AlertBoxCreateManyWithoutPageInput;
  quickTips?: QuickTipCreateManyWithoutPageInput;
  faqs?: PageFaqCreateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionCreateManyWithoutPageInput;
  grids?: GridCreateManyWithoutPageInput;
}

export interface QuickTipCreateInput {
  id?: ID_Input;
  page: PageCreateOneWithoutQuickTipsInput;
  title?: String;
  content?: String;
  buttonText?: String;
  buttonLink?: String;
  media?: MediaCreateOneInput;
  order?: Int;
}

export interface ConsUpdateInput {
  prosAndCons?: ProsAndConsUpdateOneRequiredWithoutConsInput;
  content?: String;
  order?: Int;
}

export interface PageFaqAccordionUpdateManyMutationInput {
  order?: Int;
}

export interface ProsAndConsUpdateOneRequiredWithoutConsInput {
  create?: ProsAndConsCreateWithoutConsInput;
  update?: ProsAndConsUpdateWithoutConsDataInput;
  upsert?: ProsAndConsUpsertWithoutConsInput;
  connect?: ProsAndConsWhereUniqueInput;
}

export type PageFaqWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProsAndConsUpdateWithoutConsDataInput {
  page?: PageUpdateOneRequiredWithoutProsAndConsInput;
  title?: String;
  order?: Int;
  pros?: ProsUpdateManyWithoutProsAndConsInput;
}

export type QuickTipWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PageUpdateOneRequiredWithoutProsAndConsInput {
  create?: PageCreateWithoutProsAndConsInput;
  update?: PageUpdateWithoutProsAndConsDataInput;
  upsert?: PageUpsertWithoutProsAndConsInput;
  connect?: PageWhereUniqueInput;
}

export interface BoxCreateManyWithoutPageInput {
  create?: BoxCreateWithoutPageInput[] | BoxCreateWithoutPageInput;
  connect?: BoxWhereUniqueInput[] | BoxWhereUniqueInput;
}

export interface PageUpdateWithoutProsAndConsDataInput {
  title?: String;
  slug?: String;
  url?: String;
  type?: PageType;
  status?: PageStatus;
  content?: String;
  vertical?: String;
  media?: MediaUpdateOneInput;
  template?: String;
  blocks?: BlockUpdateManyWithoutPageInput;
  boxes?: BoxUpdateManyWithoutPageInput;
  alertBoxes?: AlertBoxUpdateManyWithoutPageInput;
  quickTips?: QuickTipUpdateManyWithoutPageInput;
  faqs?: PageFaqUpdateManyWithoutPageInput;
  faqAccordion?: PageFaqAccordionUpdateManyWithoutPageInput;
  grids?: GridUpdateManyWithoutPageInput;
}

export interface UserCreatepermissionsInput {
  set?: Permission[] | Permission;
}

export interface PageUpsertWithoutProsAndConsInput {
  update: PageUpdateWithoutProsAndConsDataInput;
  create: PageCreateWithoutProsAndConsInput;
}

export interface PageUpdateOneRequiredWithoutAlertBoxesInput {
  create?: PageCreateWithoutAlertBoxesInput;
  update?: PageUpdateWithoutAlertBoxesDataInput;
  upsert?: PageUpsertWithoutAlertBoxesInput;
  connect?: PageWhereUniqueInput;
}

export interface ProsAndConsUpsertWithoutConsInput {
  update: ProsAndConsUpdateWithoutConsDataInput;
  create: ProsAndConsCreateWithoutConsInput;
}

export interface MediaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MediaWhereInput;
  AND?: MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput;
  OR?: MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput;
  NOT?: MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput;
}

export interface ConsUpdateManyMutationInput {
  content?: String;
  order?: Int;
}

export interface ProsAndConsUpdateWithoutProsDataInput {
  page?: PageUpdateOneRequiredWithoutProsAndConsInput;
  title?: String;
  order?: Int;
  cons?: ConsUpdateManyWithoutProsAndConsInput;
}

export interface FaqUpdateInput {
  title?: String;
  description?: String;
  short_description?: String;
  authors?: UserUpdateManyInput;
  slug?: String;
  vertical?: String;
  category?: FaqCategoryUpdateManyWithoutFaqsInput;
  readingTime?: Int;
  order?: Int;
  variant?: FaqUpdatevariantInput;
  tag?: FaqUpdatetagInput;
  pubDate?: DateTimeInput;
}

export type ProsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FaqUpdateManyMutationInput {
  title?: String;
  description?: String;
  short_description?: String;
  slug?: String;
  vertical?: String;
  readingTime?: Int;
  order?: Int;
  variant?: FaqUpdatevariantInput;
  tag?: FaqUpdatetagInput;
  pubDate?: DateTimeInput;
}

export interface QuickTipCreateManyWithoutPageInput {
  create?: QuickTipCreateWithoutPageInput[] | QuickTipCreateWithoutPageInput;
  connect?: QuickTipWhereUniqueInput[] | QuickTipWhereUniqueInput;
}

export interface GridItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  grid?: GridWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  linkText?: String;
  linkText_not?: String;
  linkText_in?: String[] | String;
  linkText_not_in?: String[] | String;
  linkText_lt?: String;
  linkText_lte?: String;
  linkText_gt?: String;
  linkText_gte?: String;
  linkText_contains?: String;
  linkText_not_contains?: String;
  linkText_starts_with?: String;
  linkText_not_starts_with?: String;
  linkText_ends_with?: String;
  linkText_not_ends_with?: String;
  linkUrl?: String;
  linkUrl_not?: String;
  linkUrl_in?: String[] | String;
  linkUrl_not_in?: String[] | String;
  linkUrl_lt?: String;
  linkUrl_lte?: String;
  linkUrl_gt?: String;
  linkUrl_gte?: String;
  linkUrl_contains?: String;
  linkUrl_not_contains?: String;
  linkUrl_starts_with?: String;
  linkUrl_not_starts_with?: String;
  linkUrl_ends_with?: String;
  linkUrl_not_ends_with?: String;
  media?: MediaWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: GridItemWhereInput[] | GridItemWhereInput;
  OR?: GridItemWhereInput[] | GridItemWhereInput;
  NOT?: GridItemWhereInput[] | GridItemWhereInput;
}

export interface PageCreateOneWithoutGridsInput {
  create?: PageCreateWithoutGridsInput;
  connect?: PageWhereUniqueInput;
}

export interface GridCreateInput {
  id?: ID_Input;
  title?: String;
  page: PageCreateOneWithoutGridsInput;
  media?: MediaCreateOneInput;
  content?: String;
  order?: Int;
  items?: GridItemCreateManyWithoutGridInput;
}

export interface FaqCategoryUpdateManyMutationInput {
  name?: String;
  slug?: String;
  description?: String;
}

export interface FaqCategoryUpdateInput {
  name?: String;
  slug?: String;
  description?: String;
  faqs?: FaqUpdateManyWithoutCategoryInput;
}

export interface PageUpsertWithoutQuickTipsInput {
  update: PageUpdateWithoutQuickTipsDataInput;
  create: PageCreateWithoutQuickTipsInput;
}

export interface FaqCategoryCreateInput {
  id?: ID_Input;
  name: String;
  slug: String;
  description: String;
  faqs?: FaqCreateManyWithoutCategoryInput;
}

export interface PageCreateOneWithoutFaqAccordionInput {
  create?: PageCreateWithoutFaqAccordionInput;
  connect?: PageWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions: Permission[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  permissions: () => Promise<Permission[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  permissions: () => Promise<AsyncIterator<Permission[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateAlertBox {
  count: Int;
}

export interface AggregateAlertBoxPromise
  extends Promise<AggregateAlertBox>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAlertBoxSubscription
  extends Promise<AsyncIterator<AggregateAlertBox>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Box {
  id: ID_Output;
  title?: String;
  video?: String;
  style?: String;
  alignment?: String;
  content?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BoxPromise extends Promise<Box>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  video: () => Promise<String>;
  style: () => Promise<String>;
  alignment: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BoxSubscription
  extends Promise<AsyncIterator<Box>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = PageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  media: <T = MediaSubscription>() => T;
  video: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  alignment: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AlertBoxEdge {
  node: AlertBox;
  cursor: String;
}

export interface AlertBoxEdgePromise
  extends Promise<AlertBoxEdge>,
    Fragmentable {
  node: <T = AlertBoxPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AlertBoxEdgeSubscription
  extends Promise<AsyncIterator<AlertBoxEdge>>,
    Fragmentable {
  node: <T = AlertBoxSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface QuickTipEdge {
  node: QuickTip;
  cursor: String;
}

export interface QuickTipEdgePromise
  extends Promise<QuickTipEdge>,
    Fragmentable {
  node: <T = QuickTipPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuickTipEdgeSubscription
  extends Promise<AsyncIterator<QuickTipEdge>>,
    Fragmentable {
  node: <T = QuickTipSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AlertBoxConnection {
  pageInfo: PageInfo;
  edges: AlertBoxEdge[];
}

export interface AlertBoxConnectionPromise
  extends Promise<AlertBoxConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AlertBoxEdge>>() => T;
  aggregate: <T = AggregateAlertBoxPromise>() => T;
}

export interface AlertBoxConnectionSubscription
  extends Promise<AsyncIterator<AlertBoxConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AlertBoxEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAlertBoxSubscription>() => T;
}

export interface AggregateProsAndCons {
  count: Int;
}

export interface AggregateProsAndConsPromise
  extends Promise<AggregateProsAndCons>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProsAndConsSubscription
  extends Promise<AsyncIterator<AggregateProsAndCons>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GridItem {
  id: ID_Output;
  title?: String;
  content?: String;
  linkText?: String;
  linkUrl?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GridItemPromise extends Promise<GridItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  grid: <T = GridPromise>() => T;
  title: () => Promise<String>;
  content: () => Promise<String>;
  linkText: () => Promise<String>;
  linkUrl: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GridItemSubscription
  extends Promise<AsyncIterator<GridItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  grid: <T = GridSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  linkText: () => Promise<AsyncIterator<String>>;
  linkUrl: () => Promise<AsyncIterator<String>>;
  media: <T = MediaSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProsAndConsConnection {
  pageInfo: PageInfo;
  edges: ProsAndConsEdge[];
}

export interface ProsAndConsConnectionPromise
  extends Promise<ProsAndConsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProsAndConsEdge>>() => T;
  aggregate: <T = AggregateProsAndConsPromise>() => T;
}

export interface ProsAndConsConnectionSubscription
  extends Promise<AsyncIterator<ProsAndConsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProsAndConsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProsAndConsSubscription>() => T;
}

export interface AlertBox {
  id: ID_Output;
  title?: String;
  content?: String;
  prefix?: String;
  style?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AlertBoxPromise extends Promise<AlertBox>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  content: () => Promise<String>;
  prefix: () => Promise<String>;
  style: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AlertBoxSubscription
  extends Promise<AsyncIterator<AlertBox>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = PageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  prefix: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProsEdge {
  node: Pros;
  cursor: String;
}

export interface ProsEdgePromise extends Promise<ProsEdge>, Fragmentable {
  node: <T = ProsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProsEdgeSubscription
  extends Promise<AsyncIterator<ProsEdge>>,
    Fragmentable {
  node: <T = ProsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AlertBoxSubscriptionPayload {
  mutation: MutationType;
  node: AlertBox;
  updatedFields: String[];
  previousValues: AlertBoxPreviousValues;
}

export interface AlertBoxSubscriptionPayloadPromise
  extends Promise<AlertBoxSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AlertBoxPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AlertBoxPreviousValuesPromise>() => T;
}

export interface AlertBoxSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AlertBoxSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AlertBoxSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AlertBoxPreviousValuesSubscription>() => T;
}

export interface AggregatePageFaqAccordion {
  count: Int;
}

export interface AggregatePageFaqAccordionPromise
  extends Promise<AggregatePageFaqAccordion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePageFaqAccordionSubscription
  extends Promise<AsyncIterator<AggregatePageFaqAccordion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AlertBoxPreviousValues {
  id: ID_Output;
  title?: String;
  content?: String;
  prefix?: String;
  style?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AlertBoxPreviousValuesPromise
  extends Promise<AlertBoxPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  prefix: () => Promise<String>;
  style: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AlertBoxPreviousValuesSubscription
  extends Promise<AsyncIterator<AlertBoxPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  prefix: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PageFaqAccordionConnection {
  pageInfo: PageInfo;
  edges: PageFaqAccordionEdge[];
}

export interface PageFaqAccordionConnectionPromise
  extends Promise<PageFaqAccordionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PageFaqAccordionEdge>>() => T;
  aggregate: <T = AggregatePageFaqAccordionPromise>() => T;
}

export interface PageFaqAccordionConnectionSubscription
  extends Promise<AsyncIterator<PageFaqAccordionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PageFaqAccordionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePageFaqAccordionSubscription>() => T;
}

export interface Media {
  id: ID_Output;
  url: String;
  title?: String;
  altText?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MediaPromise extends Promise<Media>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  altText: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MediaSubscription
  extends Promise<AsyncIterator<Media>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  altText: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PageFaqEdge {
  node: PageFaq;
  cursor: String;
}

export interface PageFaqEdgePromise extends Promise<PageFaqEdge>, Fragmentable {
  node: <T = PageFaqPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PageFaqEdgeSubscription
  extends Promise<AsyncIterator<PageFaqEdge>>,
    Fragmentable {
  node: <T = PageFaqSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BlockSubscriptionPayload {
  mutation: MutationType;
  node: Block;
  updatedFields: String[];
  previousValues: BlockPreviousValues;
}

export interface BlockSubscriptionPayloadPromise
  extends Promise<BlockSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlockPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BlockPreviousValuesPromise>() => T;
}

export interface BlockSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlockSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlockSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BlockPreviousValuesSubscription>() => T;
}

export interface AggregatePage {
  count: Int;
}

export interface AggregatePagePromise
  extends Promise<AggregatePage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePageSubscription
  extends Promise<AsyncIterator<AggregatePage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlockPreviousValues {
  id: ID_Output;
  title?: String;
  video?: String;
  alignment?: String;
  content?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BlockPreviousValuesPromise
  extends Promise<BlockPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  video: () => Promise<String>;
  alignment: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlockPreviousValuesSubscription
  extends Promise<AsyncIterator<BlockPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  video: () => Promise<AsyncIterator<String>>;
  alignment: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PageConnection {
  pageInfo: PageInfo;
  edges: PageEdge[];
}

export interface PageConnectionPromise
  extends Promise<PageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PageEdge>>() => T;
  aggregate: <T = AggregatePagePromise>() => T;
}

export interface PageConnectionSubscription
  extends Promise<AsyncIterator<PageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PageEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePageSubscription>() => T;
}

export interface Grid {
  id: ID_Output;
  title?: String;
  content?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GridPromise extends Promise<Grid>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  page: <T = PagePromise>() => T;
  media: <T = MediaPromise>() => T;
  content: () => Promise<String>;
  order: () => Promise<Int>;
  items: <T = FragmentableArray<GridItem>>(args?: {
    where?: GridItemWhereInput;
    orderBy?: GridItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GridSubscription
  extends Promise<AsyncIterator<Grid>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  page: <T = PageSubscription>() => T;
  media: <T = MediaSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  items: <T = Promise<AsyncIterator<GridItemSubscription>>>(args?: {
    where?: GridItemWhereInput;
    orderBy?: GridItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateMedia {
  count: Int;
}

export interface AggregateMediaPromise
  extends Promise<AggregateMedia>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMediaSubscription
  extends Promise<AsyncIterator<AggregateMedia>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BoxSubscriptionPayload {
  mutation: MutationType;
  node: Box;
  updatedFields: String[];
  previousValues: BoxPreviousValues;
}

export interface BoxSubscriptionPayloadPromise
  extends Promise<BoxSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BoxPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BoxPreviousValuesPromise>() => T;
}

export interface BoxSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BoxSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BoxSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BoxPreviousValuesSubscription>() => T;
}

export interface MediaConnection {
  pageInfo: PageInfo;
  edges: MediaEdge[];
}

export interface MediaConnectionPromise
  extends Promise<MediaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MediaEdge>>() => T;
  aggregate: <T = AggregateMediaPromise>() => T;
}

export interface MediaConnectionSubscription
  extends Promise<AsyncIterator<MediaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MediaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMediaSubscription>() => T;
}

export interface BoxPreviousValues {
  id: ID_Output;
  title?: String;
  video?: String;
  style?: String;
  alignment?: String;
  content?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BoxPreviousValuesPromise
  extends Promise<BoxPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  video: () => Promise<String>;
  style: () => Promise<String>;
  alignment: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BoxPreviousValuesSubscription
  extends Promise<AsyncIterator<BoxPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  video: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  alignment: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateGridItem {
  count: Int;
}

export interface AggregateGridItemPromise
  extends Promise<AggregateGridItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGridItemSubscription
  extends Promise<AsyncIterator<AggregateGridItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuickTipPreviousValues {
  id: ID_Output;
  title?: String;
  content?: String;
  buttonText?: String;
  buttonLink?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface QuickTipPreviousValuesPromise
  extends Promise<QuickTipPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  buttonText: () => Promise<String>;
  buttonLink: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface QuickTipPreviousValuesSubscription
  extends Promise<AsyncIterator<QuickTipPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  buttonText: () => Promise<AsyncIterator<String>>;
  buttonLink: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GridItemConnection {
  pageInfo: PageInfo;
  edges: GridItemEdge[];
}

export interface GridItemConnectionPromise
  extends Promise<GridItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GridItemEdge>>() => T;
  aggregate: <T = AggregateGridItemPromise>() => T;
}

export interface GridItemConnectionSubscription
  extends Promise<AsyncIterator<GridItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GridItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGridItemSubscription>() => T;
}

export interface ConsSubscriptionPayload {
  mutation: MutationType;
  node: Cons;
  updatedFields: String[];
  previousValues: ConsPreviousValues;
}

export interface ConsSubscriptionPayloadPromise
  extends Promise<ConsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConsPreviousValuesPromise>() => T;
}

export interface ConsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ConsPreviousValuesSubscription>() => T;
}

export interface GridEdge {
  node: Grid;
  cursor: String;
}

export interface GridEdgePromise extends Promise<GridEdge>, Fragmentable {
  node: <T = GridPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GridEdgeSubscription
  extends Promise<AsyncIterator<GridEdge>>,
    Fragmentable {
  node: <T = GridSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ConsPreviousValues {
  id: ID_Output;
  content?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ConsPreviousValuesPromise
  extends Promise<ConsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ConsPreviousValuesSubscription
  extends Promise<AsyncIterator<ConsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateFaqCategory {
  count: Int;
}

export interface AggregateFaqCategoryPromise
  extends Promise<AggregateFaqCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFaqCategorySubscription
  extends Promise<AsyncIterator<AggregateFaqCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageFaqAccordion {
  id: ID_Output;
  order?: Int;
}

export interface PageFaqAccordionPromise
  extends Promise<PageFaqAccordion>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  page: <T = PagePromise>() => T;
  faqCategory: <T = FaqCategoryPromise>() => T;
}

export interface PageFaqAccordionSubscription
  extends Promise<AsyncIterator<PageFaqAccordion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  page: <T = PageSubscription>() => T;
  faqCategory: <T = FaqCategorySubscription>() => T;
}

export interface FaqCategoryConnection {
  pageInfo: PageInfo;
  edges: FaqCategoryEdge[];
}

export interface FaqCategoryConnectionPromise
  extends Promise<FaqCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FaqCategoryEdge>>() => T;
  aggregate: <T = AggregateFaqCategoryPromise>() => T;
}

export interface FaqCategoryConnectionSubscription
  extends Promise<AsyncIterator<FaqCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FaqCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFaqCategorySubscription>() => T;
}

export interface FaqSubscriptionPayload {
  mutation: MutationType;
  node: Faq;
  updatedFields: String[];
  previousValues: FaqPreviousValues;
}

export interface FaqSubscriptionPayloadPromise
  extends Promise<FaqSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FaqPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FaqPreviousValuesPromise>() => T;
}

export interface FaqSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FaqSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FaqSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FaqPreviousValuesSubscription>() => T;
}

export interface FaqEdge {
  node: Faq;
  cursor: String;
}

export interface FaqEdgePromise extends Promise<FaqEdge>, Fragmentable {
  node: <T = FaqPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FaqEdgeSubscription
  extends Promise<AsyncIterator<FaqEdge>>,
    Fragmentable {
  node: <T = FaqSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FaqPreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
  short_description?: String;
  slug: String;
  vertical?: String;
  readingTime?: Int;
  order?: Int;
  variant: String[];
  tag: String[];
  pubDate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FaqPreviousValuesPromise
  extends Promise<FaqPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  short_description: () => Promise<String>;
  slug: () => Promise<String>;
  vertical: () => Promise<String>;
  readingTime: () => Promise<Int>;
  order: () => Promise<Int>;
  variant: () => Promise<String[]>;
  tag: () => Promise<String[]>;
  pubDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FaqPreviousValuesSubscription
  extends Promise<AsyncIterator<FaqPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  short_description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  vertical: () => Promise<AsyncIterator<String>>;
  readingTime: () => Promise<AsyncIterator<Int>>;
  order: () => Promise<AsyncIterator<Int>>;
  variant: () => Promise<AsyncIterator<String[]>>;
  tag: () => Promise<AsyncIterator<String[]>>;
  pubDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCons {
  count: Int;
}

export interface AggregateConsPromise
  extends Promise<AggregateCons>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConsSubscription
  extends Promise<AsyncIterator<AggregateCons>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FaqCategory {
  id: ID_Output;
  name: String;
  slug: String;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FaqCategoryPromise extends Promise<FaqCategory>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  description: () => Promise<String>;
  faqs: <T = FragmentableArray<Faq>>(args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FaqCategorySubscription
  extends Promise<AsyncIterator<FaqCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  faqs: <T = Promise<AsyncIterator<FaqSubscription>>>(args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ConsConnection {
  pageInfo: PageInfo;
  edges: ConsEdge[];
}

export interface ConsConnectionPromise
  extends Promise<ConsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConsEdge>>() => T;
  aggregate: <T = AggregateConsPromise>() => T;
}

export interface ConsConnectionSubscription
  extends Promise<AsyncIterator<ConsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ConsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateConsSubscription>() => T;
}

export interface FaqCategorySubscriptionPayload {
  mutation: MutationType;
  node: FaqCategory;
  updatedFields: String[];
  previousValues: FaqCategoryPreviousValues;
}

export interface FaqCategorySubscriptionPayloadPromise
  extends Promise<FaqCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FaqCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FaqCategoryPreviousValuesPromise>() => T;
}

export interface FaqCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FaqCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FaqCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FaqCategoryPreviousValuesSubscription>() => T;
}

export interface BoxEdge {
  node: Box;
  cursor: String;
}

export interface BoxEdgePromise extends Promise<BoxEdge>, Fragmentable {
  node: <T = BoxPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BoxEdgeSubscription
  extends Promise<AsyncIterator<BoxEdge>>,
    Fragmentable {
  node: <T = BoxSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FaqCategoryPreviousValues {
  id: ID_Output;
  name: String;
  slug: String;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FaqCategoryPreviousValuesPromise
  extends Promise<FaqCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FaqCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<FaqCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBlock {
  count: Int;
}

export interface AggregateBlockPromise
  extends Promise<AggregateBlock>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlockSubscription
  extends Promise<AsyncIterator<AggregateBlock>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions: Permission[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  permissions: () => Promise<Permission[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  permissions: () => Promise<AsyncIterator<Permission[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BlockConnection {
  pageInfo: PageInfo;
  edges: BlockEdge[];
}

export interface BlockConnectionPromise
  extends Promise<BlockConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlockEdge>>() => T;
  aggregate: <T = AggregateBlockPromise>() => T;
}

export interface BlockConnectionSubscription
  extends Promise<AsyncIterator<BlockConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlockEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlockSubscription>() => T;
}

export interface GridSubscriptionPayload {
  mutation: MutationType;
  node: Grid;
  updatedFields: String[];
  previousValues: GridPreviousValues;
}

export interface GridSubscriptionPayloadPromise
  extends Promise<GridSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GridPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GridPreviousValuesPromise>() => T;
}

export interface GridSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GridSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GridSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GridPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GridPreviousValues {
  id: ID_Output;
  title?: String;
  content?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GridPreviousValuesPromise
  extends Promise<GridPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GridPreviousValuesSubscription
  extends Promise<AsyncIterator<GridPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface QuickTipConnection {
  pageInfo: PageInfo;
  edges: QuickTipEdge[];
}

export interface QuickTipConnectionPromise
  extends Promise<QuickTipConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuickTipEdge>>() => T;
  aggregate: <T = AggregateQuickTipPromise>() => T;
}

export interface QuickTipConnectionSubscription
  extends Promise<AsyncIterator<QuickTipConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuickTipEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuickTipSubscription>() => T;
}

export interface QuickTipSubscriptionPayload {
  mutation: MutationType;
  node: QuickTip;
  updatedFields: String[];
  previousValues: QuickTipPreviousValues;
}

export interface QuickTipSubscriptionPayloadPromise
  extends Promise<QuickTipSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuickTipPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuickTipPreviousValuesPromise>() => T;
}

export interface QuickTipSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuickTipSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuickTipSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuickTipPreviousValuesSubscription>() => T;
}

export interface AggregatePros {
  count: Int;
}

export interface AggregateProsPromise
  extends Promise<AggregatePros>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProsSubscription
  extends Promise<AsyncIterator<AggregatePros>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GridItemSubscriptionPayload {
  mutation: MutationType;
  node: GridItem;
  updatedFields: String[];
  previousValues: GridItemPreviousValues;
}

export interface GridItemSubscriptionPayloadPromise
  extends Promise<GridItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GridItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GridItemPreviousValuesPromise>() => T;
}

export interface GridItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GridItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GridItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GridItemPreviousValuesSubscription>() => T;
}

export interface PageFaqAccordionEdge {
  node: PageFaqAccordion;
  cursor: String;
}

export interface PageFaqAccordionEdgePromise
  extends Promise<PageFaqAccordionEdge>,
    Fragmentable {
  node: <T = PageFaqAccordionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PageFaqAccordionEdgeSubscription
  extends Promise<AsyncIterator<PageFaqAccordionEdge>>,
    Fragmentable {
  node: <T = PageFaqAccordionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GridItemPreviousValues {
  id: ID_Output;
  title?: String;
  content?: String;
  linkText?: String;
  linkUrl?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GridItemPreviousValuesPromise
  extends Promise<GridItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  linkText: () => Promise<String>;
  linkUrl: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GridItemPreviousValuesSubscription
  extends Promise<AsyncIterator<GridItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  linkText: () => Promise<AsyncIterator<String>>;
  linkUrl: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PageFaqConnection {
  pageInfo: PageInfo;
  edges: PageFaqEdge[];
}

export interface PageFaqConnectionPromise
  extends Promise<PageFaqConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PageFaqEdge>>() => T;
  aggregate: <T = AggregatePageFaqPromise>() => T;
}

export interface PageFaqConnectionSubscription
  extends Promise<AsyncIterator<PageFaqConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PageFaqEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePageFaqSubscription>() => T;
}

export interface Faq {
  id: ID_Output;
  title: String;
  description?: String;
  short_description?: String;
  slug: String;
  vertical?: String;
  readingTime?: Int;
  order?: Int;
  variant: String[];
  tag: String[];
  pubDate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FaqPromise extends Promise<Faq>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  short_description: () => Promise<String>;
  authors: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  slug: () => Promise<String>;
  vertical: () => Promise<String>;
  category: <T = FragmentableArray<FaqCategory>>(args?: {
    where?: FaqCategoryWhereInput;
    orderBy?: FaqCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  readingTime: () => Promise<Int>;
  order: () => Promise<Int>;
  variant: () => Promise<String[]>;
  tag: () => Promise<String[]>;
  pubDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FaqSubscription
  extends Promise<AsyncIterator<Faq>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  short_description: () => Promise<AsyncIterator<String>>;
  authors: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  slug: () => Promise<AsyncIterator<String>>;
  vertical: () => Promise<AsyncIterator<String>>;
  category: <T = Promise<AsyncIterator<FaqCategorySubscription>>>(args?: {
    where?: FaqCategoryWhereInput;
    orderBy?: FaqCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  readingTime: () => Promise<AsyncIterator<Int>>;
  order: () => Promise<AsyncIterator<Int>>;
  variant: () => Promise<AsyncIterator<String[]>>;
  tag: () => Promise<AsyncIterator<String[]>>;
  pubDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Page {
  id: ID_Output;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  template?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PagePromise extends Promise<Page>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  slug: () => Promise<String>;
  url: () => Promise<String>;
  type: () => Promise<PageType>;
  status: () => Promise<PageStatus>;
  content: () => Promise<String>;
  vertical: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  template: () => Promise<String>;
  blocks: <T = FragmentableArray<Block>>(args?: {
    where?: BlockWhereInput;
    orderBy?: BlockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boxes: <T = FragmentableArray<Box>>(args?: {
    where?: BoxWhereInput;
    orderBy?: BoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  prosAndCons: <T = FragmentableArray<ProsAndCons>>(args?: {
    where?: ProsAndConsWhereInput;
    orderBy?: ProsAndConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  alertBoxes: <T = FragmentableArray<AlertBox>>(args?: {
    where?: AlertBoxWhereInput;
    orderBy?: AlertBoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quickTips: <T = FragmentableArray<QuickTip>>(args?: {
    where?: QuickTipWhereInput;
    orderBy?: QuickTipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  faqs: <T = FragmentableArray<PageFaq>>(args?: {
    where?: PageFaqWhereInput;
    orderBy?: PageFaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  faqAccordion: <T = FragmentableArray<PageFaqAccordion>>(args?: {
    where?: PageFaqAccordionWhereInput;
    orderBy?: PageFaqAccordionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  grids: <T = FragmentableArray<Grid>>(args?: {
    where?: GridWhereInput;
    orderBy?: GridOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PageSubscription
  extends Promise<AsyncIterator<Page>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<PageType>>;
  status: () => Promise<AsyncIterator<PageStatus>>;
  content: () => Promise<AsyncIterator<String>>;
  vertical: () => Promise<AsyncIterator<String>>;
  media: <T = MediaSubscription>() => T;
  template: () => Promise<AsyncIterator<String>>;
  blocks: <T = Promise<AsyncIterator<BlockSubscription>>>(args?: {
    where?: BlockWhereInput;
    orderBy?: BlockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boxes: <T = Promise<AsyncIterator<BoxSubscription>>>(args?: {
    where?: BoxWhereInput;
    orderBy?: BoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  prosAndCons: <T = Promise<AsyncIterator<ProsAndConsSubscription>>>(args?: {
    where?: ProsAndConsWhereInput;
    orderBy?: ProsAndConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  alertBoxes: <T = Promise<AsyncIterator<AlertBoxSubscription>>>(args?: {
    where?: AlertBoxWhereInput;
    orderBy?: AlertBoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quickTips: <T = Promise<AsyncIterator<QuickTipSubscription>>>(args?: {
    where?: QuickTipWhereInput;
    orderBy?: QuickTipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  faqs: <T = Promise<AsyncIterator<PageFaqSubscription>>>(args?: {
    where?: PageFaqWhereInput;
    orderBy?: PageFaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  faqAccordion: <
    T = Promise<AsyncIterator<PageFaqAccordionSubscription>>
  >(args?: {
    where?: PageFaqAccordionWhereInput;
    orderBy?: PageFaqAccordionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  grids: <T = Promise<AsyncIterator<GridSubscription>>>(args?: {
    where?: GridWhereInput;
    orderBy?: GridOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MediaSubscriptionPayload {
  mutation: MutationType;
  node: Media;
  updatedFields: String[];
  previousValues: MediaPreviousValues;
}

export interface MediaSubscriptionPayloadPromise
  extends Promise<MediaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MediaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MediaPreviousValuesPromise>() => T;
}

export interface MediaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MediaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MediaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MediaPreviousValuesSubscription>() => T;
}

export interface Block {
  id: ID_Output;
  title?: String;
  video?: String;
  alignment?: String;
  content?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BlockPromise extends Promise<Block>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  video: () => Promise<String>;
  alignment: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlockSubscription
  extends Promise<AsyncIterator<Block>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = PageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  media: <T = MediaSubscription>() => T;
  video: () => Promise<AsyncIterator<String>>;
  alignment: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MediaPreviousValues {
  id: ID_Output;
  url: String;
  title?: String;
  altText?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MediaPreviousValuesPromise
  extends Promise<MediaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  altText: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MediaPreviousValuesSubscription
  extends Promise<AsyncIterator<MediaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  altText: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateGrid {
  count: Int;
}

export interface AggregateGridPromise
  extends Promise<AggregateGrid>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGridSubscription
  extends Promise<AsyncIterator<AggregateGrid>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageFaq {
  id: ID_Output;
  order?: Int;
}

export interface PageFaqPromise extends Promise<PageFaq>, Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  page: <T = PagePromise>() => T;
  faq: <T = FaqPromise>() => T;
}

export interface PageFaqSubscription
  extends Promise<AsyncIterator<PageFaq>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  page: <T = PageSubscription>() => T;
  faq: <T = FaqSubscription>() => T;
}

export interface FaqCategoryEdge {
  node: FaqCategory;
  cursor: String;
}

export interface FaqCategoryEdgePromise
  extends Promise<FaqCategoryEdge>,
    Fragmentable {
  node: <T = FaqCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FaqCategoryEdgeSubscription
  extends Promise<AsyncIterator<FaqCategoryEdge>>,
    Fragmentable {
  node: <T = FaqCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageSubscriptionPayload {
  mutation: MutationType;
  node: Page;
  updatedFields: String[];
  previousValues: PagePreviousValues;
}

export interface PageSubscriptionPayloadPromise
  extends Promise<PageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PagePreviousValuesPromise>() => T;
}

export interface PageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PagePreviousValuesSubscription>() => T;
}

export interface FaqConnection {
  pageInfo: PageInfo;
  edges: FaqEdge[];
}

export interface FaqConnectionPromise
  extends Promise<FaqConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FaqEdge>>() => T;
  aggregate: <T = AggregateFaqPromise>() => T;
}

export interface FaqConnectionSubscription
  extends Promise<AsyncIterator<FaqConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FaqEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFaqSubscription>() => T;
}

export interface PagePreviousValues {
  id: ID_Output;
  title: String;
  slug: String;
  url: String;
  type: PageType;
  status: PageStatus;
  content?: String;
  vertical?: String;
  template?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PagePreviousValuesPromise
  extends Promise<PagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  slug: () => Promise<String>;
  url: () => Promise<String>;
  type: () => Promise<PageType>;
  status: () => Promise<PageStatus>;
  content: () => Promise<String>;
  vertical: () => Promise<String>;
  template: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PagePreviousValuesSubscription
  extends Promise<AsyncIterator<PagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<PageType>>;
  status: () => Promise<AsyncIterator<PageStatus>>;
  content: () => Promise<AsyncIterator<String>>;
  vertical: () => Promise<AsyncIterator<String>>;
  template: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBox {
  count: Int;
}

export interface AggregateBoxPromise
  extends Promise<AggregateBox>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBoxSubscription
  extends Promise<AsyncIterator<AggregateBox>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuickTip {
  id: ID_Output;
  title?: String;
  content?: String;
  buttonText?: String;
  buttonLink?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface QuickTipPromise extends Promise<QuickTip>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  content: () => Promise<String>;
  buttonText: () => Promise<String>;
  buttonLink: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface QuickTipSubscription
  extends Promise<AsyncIterator<QuickTip>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = PageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  buttonText: () => Promise<AsyncIterator<String>>;
  buttonLink: () => Promise<AsyncIterator<String>>;
  media: <T = MediaSubscription>() => T;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BlockEdge {
  node: Block;
  cursor: String;
}

export interface BlockEdgePromise extends Promise<BlockEdge>, Fragmentable {
  node: <T = BlockPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BlockEdgeSubscription
  extends Promise<AsyncIterator<BlockEdge>>,
    Fragmentable {
  node: <T = BlockSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageFaqSubscriptionPayload {
  mutation: MutationType;
  node: PageFaq;
  updatedFields: String[];
  previousValues: PageFaqPreviousValues;
}

export interface PageFaqSubscriptionPayloadPromise
  extends Promise<PageFaqSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PageFaqPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PageFaqPreviousValuesPromise>() => T;
}

export interface PageFaqSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PageFaqSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PageFaqSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PageFaqPreviousValuesSubscription>() => T;
}

export interface AggregateQuickTip {
  count: Int;
}

export interface AggregateQuickTipPromise
  extends Promise<AggregateQuickTip>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuickTipSubscription
  extends Promise<AsyncIterator<AggregateQuickTip>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageFaqPreviousValues {
  id: ID_Output;
  order?: Int;
}

export interface PageFaqPreviousValuesPromise
  extends Promise<PageFaqPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
}

export interface PageFaqPreviousValuesSubscription
  extends Promise<AsyncIterator<PageFaqPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface ProsConnection {
  pageInfo: PageInfo;
  edges: ProsEdge[];
}

export interface ProsConnectionPromise
  extends Promise<ProsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProsEdge>>() => T;
  aggregate: <T = AggregateProsPromise>() => T;
}

export interface ProsConnectionSubscription
  extends Promise<AsyncIterator<ProsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProsSubscription>() => T;
}

export interface Cons {
  id: ID_Output;
  content?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ConsPromise extends Promise<Cons>, Fragmentable {
  id: () => Promise<ID_Output>;
  prosAndCons: <T = ProsAndConsPromise>() => T;
  content: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ConsSubscription
  extends Promise<AsyncIterator<Cons>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  prosAndCons: <T = ProsAndConsSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PageEdge {
  node: Page;
  cursor: String;
}

export interface PageEdgePromise extends Promise<PageEdge>, Fragmentable {
  node: <T = PagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PageEdgeSubscription
  extends Promise<AsyncIterator<PageEdge>>,
    Fragmentable {
  node: <T = PageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageFaqAccordionSubscriptionPayload {
  mutation: MutationType;
  node: PageFaqAccordion;
  updatedFields: String[];
  previousValues: PageFaqAccordionPreviousValues;
}

export interface PageFaqAccordionSubscriptionPayloadPromise
  extends Promise<PageFaqAccordionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PageFaqAccordionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PageFaqAccordionPreviousValuesPromise>() => T;
}

export interface PageFaqAccordionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PageFaqAccordionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PageFaqAccordionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PageFaqAccordionPreviousValuesSubscription>() => T;
}

export interface GridItemEdge {
  node: GridItem;
  cursor: String;
}

export interface GridItemEdgePromise
  extends Promise<GridItemEdge>,
    Fragmentable {
  node: <T = GridItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GridItemEdgeSubscription
  extends Promise<AsyncIterator<GridItemEdge>>,
    Fragmentable {
  node: <T = GridItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageFaqAccordionPreviousValues {
  id: ID_Output;
  order?: Int;
}

export interface PageFaqAccordionPreviousValuesPromise
  extends Promise<PageFaqAccordionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
}

export interface PageFaqAccordionPreviousValuesSubscription
  extends Promise<AsyncIterator<PageFaqAccordionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateFaq {
  count: Int;
}

export interface AggregateFaqPromise
  extends Promise<AggregateFaq>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFaqSubscription
  extends Promise<AsyncIterator<AggregateFaq>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Pros {
  id: ID_Output;
  content?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProsPromise extends Promise<Pros>, Fragmentable {
  id: () => Promise<ID_Output>;
  prosAndCons: <T = ProsAndConsPromise>() => T;
  content: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProsSubscription
  extends Promise<AsyncIterator<Pros>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  prosAndCons: <T = ProsAndConsSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BoxConnection {
  pageInfo: PageInfo;
  edges: BoxEdge[];
}

export interface BoxConnectionPromise
  extends Promise<BoxConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BoxEdge>>() => T;
  aggregate: <T = AggregateBoxPromise>() => T;
}

export interface BoxConnectionSubscription
  extends Promise<AsyncIterator<BoxConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BoxEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBoxSubscription>() => T;
}

export interface ProsSubscriptionPayload {
  mutation: MutationType;
  node: Pros;
  updatedFields: String[];
  previousValues: ProsPreviousValues;
}

export interface ProsSubscriptionPayloadPromise
  extends Promise<ProsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProsPreviousValuesPromise>() => T;
}

export interface ProsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProsPreviousValuesSubscription>() => T;
}

export interface ProsAndConsEdge {
  node: ProsAndCons;
  cursor: String;
}

export interface ProsAndConsEdgePromise
  extends Promise<ProsAndConsEdge>,
    Fragmentable {
  node: <T = ProsAndConsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProsAndConsEdgeSubscription
  extends Promise<AsyncIterator<ProsAndConsEdge>>,
    Fragmentable {
  node: <T = ProsAndConsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProsAndConsPreviousValues {
  id: ID_Output;
  title?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProsAndConsPreviousValuesPromise
  extends Promise<ProsAndConsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProsAndConsPreviousValuesSubscription
  extends Promise<AsyncIterator<ProsAndConsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProsAndConsSubscriptionPayload {
  mutation: MutationType;
  node: ProsAndCons;
  updatedFields: String[];
  previousValues: ProsAndConsPreviousValues;
}

export interface ProsAndConsSubscriptionPayloadPromise
  extends Promise<ProsAndConsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProsAndConsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProsAndConsPreviousValuesPromise>() => T;
}

export interface ProsAndConsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProsAndConsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProsAndConsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProsAndConsPreviousValuesSubscription>() => T;
}

export interface ProsAndCons {
  id: ID_Output;
  title?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProsAndConsPromise extends Promise<ProsAndCons>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  order: () => Promise<Int>;
  pros: <T = FragmentableArray<Pros>>(args?: {
    where?: ProsWhereInput;
    orderBy?: ProsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cons: <T = FragmentableArray<Cons>>(args?: {
    where?: ConsWhereInput;
    orderBy?: ConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProsAndConsSubscription
  extends Promise<AsyncIterator<ProsAndCons>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = PageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  pros: <T = Promise<AsyncIterator<ProsSubscription>>>(args?: {
    where?: ProsWhereInput;
    orderBy?: ProsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cons: <T = Promise<AsyncIterator<ConsSubscription>>>(args?: {
    where?: ConsWhereInput;
    orderBy?: ConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProsPreviousValues {
  id: ID_Output;
  content?: String;
  order?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProsPreviousValuesPromise
  extends Promise<ProsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProsPreviousValuesSubscription
  extends Promise<AsyncIterator<ProsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePageFaq {
  count: Int;
}

export interface AggregatePageFaqPromise
  extends Promise<AggregatePageFaq>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePageFaqSubscription
  extends Promise<AsyncIterator<AggregatePageFaq>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ConsEdge {
  node: Cons;
  cursor: String;
}

export interface ConsEdgePromise extends Promise<ConsEdge>, Fragmentable {
  node: <T = ConsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConsEdgeSubscription
  extends Promise<AsyncIterator<ConsEdge>>,
    Fragmentable {
  node: <T = ConsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GridConnection {
  pageInfo: PageInfo;
  edges: GridEdge[];
}

export interface GridConnectionPromise
  extends Promise<GridConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GridEdge>>() => T;
  aggregate: <T = AggregateGridPromise>() => T;
}

export interface GridConnectionSubscription
  extends Promise<AsyncIterator<GridConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GridEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGridSubscription>() => T;
}

export interface MediaEdge {
  node: Media;
  cursor: String;
}

export interface MediaEdgePromise extends Promise<MediaEdge>, Fragmentable {
  node: <T = MediaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MediaEdgeSubscription
  extends Promise<AsyncIterator<MediaEdge>>,
    Fragmentable {
  node: <T = MediaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "PageType",
    embedded: false
  },
  {
    name: "PageStatus",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Page",
    embedded: false
  },
  {
    name: "Block",
    embedded: false
  },
  {
    name: "Box",
    embedded: false
  },
  {
    name: "AlertBox",
    embedded: false
  },
  {
    name: "QuickTip",
    embedded: false
  },
  {
    name: "ProsAndCons",
    embedded: false
  },
  {
    name: "Pros",
    embedded: false
  },
  {
    name: "Cons",
    embedded: false
  },
  {
    name: "Faq",
    embedded: false
  },
  {
    name: "FaqCategory",
    embedded: false
  },
  {
    name: "Media",
    embedded: false
  },
  {
    name: "PageFaq",
    embedded: false
  },
  {
    name: "PageFaqAccordion",
    embedded: false
  },
  {
    name: "Grid",
    embedded: false
  },
  {
    name: "GridItem",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
