// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  alertBox: (where?: AlertBoxWhereInput) => Promise<boolean>;
  block: (where?: BlockWhereInput) => Promise<boolean>;
  box: (where?: BoxWhereInput) => Promise<boolean>;
  cons: (where?: ConsWhereInput) => Promise<boolean>;
  faq: (where?: FaqWhereInput) => Promise<boolean>;
  faqCategory: (where?: FaqCategoryWhereInput) => Promise<boolean>;
  media: (where?: MediaWhereInput) => Promise<boolean>;
  page: (where?: PageWhereInput) => Promise<boolean>;
  pros: (where?: ProsWhereInput) => Promise<boolean>;
  prosAndCons: (where?: ProsAndConsWhereInput) => Promise<boolean>;
  quickTip: (where?: QuickTipWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  alertBox: (where: AlertBoxWhereUniqueInput) => AlertBoxNullablePromise;
  alertBoxes: (args?: {
    where?: AlertBoxWhereInput;
    orderBy?: AlertBoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AlertBox>;
  alertBoxesConnection: (args?: {
    where?: AlertBoxWhereInput;
    orderBy?: AlertBoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AlertBoxConnectionPromise;
  block: (where: BlockWhereUniqueInput) => BlockNullablePromise;
  blocks: (args?: {
    where?: BlockWhereInput;
    orderBy?: BlockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Block>;
  blocksConnection: (args?: {
    where?: BlockWhereInput;
    orderBy?: BlockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BlockConnectionPromise;
  box: (where: BoxWhereUniqueInput) => BoxNullablePromise;
  boxes: (args?: {
    where?: BoxWhereInput;
    orderBy?: BoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Box>;
  boxesConnection: (args?: {
    where?: BoxWhereInput;
    orderBy?: BoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BoxConnectionPromise;
  cons: (where: ConsWhereUniqueInput) => ConsNullablePromise;
  conses: (args?: {
    where?: ConsWhereInput;
    orderBy?: ConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Cons>;
  consesConnection: (args?: {
    where?: ConsWhereInput;
    orderBy?: ConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ConsConnectionPromise;
  faq: (where: FaqWhereUniqueInput) => FaqNullablePromise;
  faqs: (args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Faq>;
  faqsConnection: (args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FaqConnectionPromise;
  faqCategory: (
    where: FaqCategoryWhereUniqueInput
  ) => FaqCategoryNullablePromise;
  faqCategories: (args?: {
    where?: FaqCategoryWhereInput;
    orderBy?: FaqCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FaqCategory>;
  faqCategoriesConnection: (args?: {
    where?: FaqCategoryWhereInput;
    orderBy?: FaqCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FaqCategoryConnectionPromise;
  media: (where: MediaWhereUniqueInput) => MediaNullablePromise;
  medias: (args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Media>;
  mediasConnection: (args?: {
    where?: MediaWhereInput;
    orderBy?: MediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MediaConnectionPromise;
  page: (where: PageWhereUniqueInput) => PageNullablePromise;
  pages: (args?: {
    where?: PageWhereInput;
    orderBy?: PageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Page>;
  pagesConnection: (args?: {
    where?: PageWhereInput;
    orderBy?: PageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PageConnectionPromise;
  pros: (where: ProsWhereUniqueInput) => ProsNullablePromise;
  proses: (args?: {
    where?: ProsWhereInput;
    orderBy?: ProsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Pros>;
  prosesConnection: (args?: {
    where?: ProsWhereInput;
    orderBy?: ProsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProsConnectionPromise;
  prosAndCons: (
    where: ProsAndConsWhereUniqueInput
  ) => ProsAndConsNullablePromise;
  prosAndConses: (args?: {
    where?: ProsAndConsWhereInput;
    orderBy?: ProsAndConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProsAndCons>;
  prosAndConsesConnection: (args?: {
    where?: ProsAndConsWhereInput;
    orderBy?: ProsAndConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProsAndConsConnectionPromise;
  quickTip: (where: QuickTipWhereUniqueInput) => QuickTipNullablePromise;
  quickTips: (args?: {
    where?: QuickTipWhereInput;
    orderBy?: QuickTipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuickTip>;
  quickTipsConnection: (args?: {
    where?: QuickTipWhereInput;
    orderBy?: QuickTipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuickTipConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAlertBox: (data: AlertBoxCreateInput) => AlertBoxPromise;
  updateAlertBox: (args: {
    data: AlertBoxUpdateInput;
    where: AlertBoxWhereUniqueInput;
  }) => AlertBoxPromise;
  updateManyAlertBoxes: (args: {
    data: AlertBoxUpdateManyMutationInput;
    where?: AlertBoxWhereInput;
  }) => BatchPayloadPromise;
  upsertAlertBox: (args: {
    where: AlertBoxWhereUniqueInput;
    create: AlertBoxCreateInput;
    update: AlertBoxUpdateInput;
  }) => AlertBoxPromise;
  deleteAlertBox: (where: AlertBoxWhereUniqueInput) => AlertBoxPromise;
  deleteManyAlertBoxes: (where?: AlertBoxWhereInput) => BatchPayloadPromise;
  createBlock: (data: BlockCreateInput) => BlockPromise;
  updateBlock: (args: {
    data: BlockUpdateInput;
    where: BlockWhereUniqueInput;
  }) => BlockPromise;
  updateManyBlocks: (args: {
    data: BlockUpdateManyMutationInput;
    where?: BlockWhereInput;
  }) => BatchPayloadPromise;
  upsertBlock: (args: {
    where: BlockWhereUniqueInput;
    create: BlockCreateInput;
    update: BlockUpdateInput;
  }) => BlockPromise;
  deleteBlock: (where: BlockWhereUniqueInput) => BlockPromise;
  deleteManyBlocks: (where?: BlockWhereInput) => BatchPayloadPromise;
  createBox: (data: BoxCreateInput) => BoxPromise;
  updateBox: (args: {
    data: BoxUpdateInput;
    where: BoxWhereUniqueInput;
  }) => BoxPromise;
  updateManyBoxes: (args: {
    data: BoxUpdateManyMutationInput;
    where?: BoxWhereInput;
  }) => BatchPayloadPromise;
  upsertBox: (args: {
    where: BoxWhereUniqueInput;
    create: BoxCreateInput;
    update: BoxUpdateInput;
  }) => BoxPromise;
  deleteBox: (where: BoxWhereUniqueInput) => BoxPromise;
  deleteManyBoxes: (where?: BoxWhereInput) => BatchPayloadPromise;
  createCons: (data: ConsCreateInput) => ConsPromise;
  updateCons: (args: {
    data: ConsUpdateInput;
    where: ConsWhereUniqueInput;
  }) => ConsPromise;
  updateManyConses: (args: {
    data: ConsUpdateManyMutationInput;
    where?: ConsWhereInput;
  }) => BatchPayloadPromise;
  upsertCons: (args: {
    where: ConsWhereUniqueInput;
    create: ConsCreateInput;
    update: ConsUpdateInput;
  }) => ConsPromise;
  deleteCons: (where: ConsWhereUniqueInput) => ConsPromise;
  deleteManyConses: (where?: ConsWhereInput) => BatchPayloadPromise;
  createFaq: (data: FaqCreateInput) => FaqPromise;
  updateFaq: (args: {
    data: FaqUpdateInput;
    where: FaqWhereUniqueInput;
  }) => FaqPromise;
  updateManyFaqs: (args: {
    data: FaqUpdateManyMutationInput;
    where?: FaqWhereInput;
  }) => BatchPayloadPromise;
  upsertFaq: (args: {
    where: FaqWhereUniqueInput;
    create: FaqCreateInput;
    update: FaqUpdateInput;
  }) => FaqPromise;
  deleteFaq: (where: FaqWhereUniqueInput) => FaqPromise;
  deleteManyFaqs: (where?: FaqWhereInput) => BatchPayloadPromise;
  createFaqCategory: (data: FaqCategoryCreateInput) => FaqCategoryPromise;
  updateFaqCategory: (args: {
    data: FaqCategoryUpdateInput;
    where: FaqCategoryWhereUniqueInput;
  }) => FaqCategoryPromise;
  updateManyFaqCategories: (args: {
    data: FaqCategoryUpdateManyMutationInput;
    where?: FaqCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertFaqCategory: (args: {
    where: FaqCategoryWhereUniqueInput;
    create: FaqCategoryCreateInput;
    update: FaqCategoryUpdateInput;
  }) => FaqCategoryPromise;
  deleteFaqCategory: (where: FaqCategoryWhereUniqueInput) => FaqCategoryPromise;
  deleteManyFaqCategories: (
    where?: FaqCategoryWhereInput
  ) => BatchPayloadPromise;
  createMedia: (data: MediaCreateInput) => MediaPromise;
  updateMedia: (args: {
    data: MediaUpdateInput;
    where: MediaWhereUniqueInput;
  }) => MediaPromise;
  updateManyMedias: (args: {
    data: MediaUpdateManyMutationInput;
    where?: MediaWhereInput;
  }) => BatchPayloadPromise;
  upsertMedia: (args: {
    where: MediaWhereUniqueInput;
    create: MediaCreateInput;
    update: MediaUpdateInput;
  }) => MediaPromise;
  deleteMedia: (where: MediaWhereUniqueInput) => MediaPromise;
  deleteManyMedias: (where?: MediaWhereInput) => BatchPayloadPromise;
  createPage: (data: PageCreateInput) => PagePromise;
  updatePage: (args: {
    data: PageUpdateInput;
    where: PageWhereUniqueInput;
  }) => PagePromise;
  updateManyPages: (args: {
    data: PageUpdateManyMutationInput;
    where?: PageWhereInput;
  }) => BatchPayloadPromise;
  upsertPage: (args: {
    where: PageWhereUniqueInput;
    create: PageCreateInput;
    update: PageUpdateInput;
  }) => PagePromise;
  deletePage: (where: PageWhereUniqueInput) => PagePromise;
  deleteManyPages: (where?: PageWhereInput) => BatchPayloadPromise;
  createPros: (data: ProsCreateInput) => ProsPromise;
  updatePros: (args: {
    data: ProsUpdateInput;
    where: ProsWhereUniqueInput;
  }) => ProsPromise;
  updateManyProses: (args: {
    data: ProsUpdateManyMutationInput;
    where?: ProsWhereInput;
  }) => BatchPayloadPromise;
  upsertPros: (args: {
    where: ProsWhereUniqueInput;
    create: ProsCreateInput;
    update: ProsUpdateInput;
  }) => ProsPromise;
  deletePros: (where: ProsWhereUniqueInput) => ProsPromise;
  deleteManyProses: (where?: ProsWhereInput) => BatchPayloadPromise;
  createProsAndCons: (data: ProsAndConsCreateInput) => ProsAndConsPromise;
  updateProsAndCons: (args: {
    data: ProsAndConsUpdateInput;
    where: ProsAndConsWhereUniqueInput;
  }) => ProsAndConsPromise;
  updateManyProsAndConses: (args: {
    data: ProsAndConsUpdateManyMutationInput;
    where?: ProsAndConsWhereInput;
  }) => BatchPayloadPromise;
  upsertProsAndCons: (args: {
    where: ProsAndConsWhereUniqueInput;
    create: ProsAndConsCreateInput;
    update: ProsAndConsUpdateInput;
  }) => ProsAndConsPromise;
  deleteProsAndCons: (where: ProsAndConsWhereUniqueInput) => ProsAndConsPromise;
  deleteManyProsAndConses: (
    where?: ProsAndConsWhereInput
  ) => BatchPayloadPromise;
  createQuickTip: (data: QuickTipCreateInput) => QuickTipPromise;
  updateQuickTip: (args: {
    data: QuickTipUpdateInput;
    where: QuickTipWhereUniqueInput;
  }) => QuickTipPromise;
  updateManyQuickTips: (args: {
    data: QuickTipUpdateManyMutationInput;
    where?: QuickTipWhereInput;
  }) => BatchPayloadPromise;
  upsertQuickTip: (args: {
    where: QuickTipWhereUniqueInput;
    create: QuickTipCreateInput;
    update: QuickTipUpdateInput;
  }) => QuickTipPromise;
  deleteQuickTip: (where: QuickTipWhereUniqueInput) => QuickTipPromise;
  deleteManyQuickTips: (where?: QuickTipWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  alertBox: (
    where?: AlertBoxSubscriptionWhereInput
  ) => AlertBoxSubscriptionPayloadSubscription;
  block: (
    where?: BlockSubscriptionWhereInput
  ) => BlockSubscriptionPayloadSubscription;
  box: (
    where?: BoxSubscriptionWhereInput
  ) => BoxSubscriptionPayloadSubscription;
  cons: (
    where?: ConsSubscriptionWhereInput
  ) => ConsSubscriptionPayloadSubscription;
  faq: (
    where?: FaqSubscriptionWhereInput
  ) => FaqSubscriptionPayloadSubscription;
  faqCategory: (
    where?: FaqCategorySubscriptionWhereInput
  ) => FaqCategorySubscriptionPayloadSubscription;
  media: (
    where?: MediaSubscriptionWhereInput
  ) => MediaSubscriptionPayloadSubscription;
  page: (
    where?: PageSubscriptionWhereInput
  ) => PageSubscriptionPayloadSubscription;
  pros: (
    where?: ProsSubscriptionWhereInput
  ) => ProsSubscriptionPayloadSubscription;
  prosAndCons: (
    where?: ProsAndConsSubscriptionWhereInput
  ) => ProsAndConsSubscriptionPayloadSubscription;
  quickTip: (
    where?: QuickTipSubscriptionWhereInput
  ) => QuickTipSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Permission = "ADMIN" | "USER";

export type BlockOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "video_ASC"
  | "video_DESC"
  | "style_ASC"
  | "style_DESC"
  | "content_ASC"
  | "content_DESC"
  | "order_ASC"
  | "order_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC";

export type PageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "type_ASC"
  | "type_DESC"
  | "status_ASC"
  | "status_DESC"
  | "vertical_ASC"
  | "vertical_DESC";

export type QuickTipOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "buttonText_ASC"
  | "buttonText_DESC"
  | "buttonLink_ASC"
  | "buttonLink_DESC"
  | "order_ASC"
  | "order_DESC";

export type PageType = "PAGE" | "NEWS" | "ARTICLE";

export type AlertBoxOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "prefix_ASC"
  | "prefix_DESC"
  | "style_ASC"
  | "style_DESC"
  | "order_ASC"
  | "order_DESC";

export type FaqOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "short_description_ASC"
  | "short_description_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "vertical_ASC"
  | "vertical_DESC"
  | "readingTime_ASC"
  | "readingTime_DESC"
  | "order_ASC"
  | "order_DESC"
  | "pubDate_ASC"
  | "pubDate_DESC";

export type BoxOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "video_ASC"
  | "video_DESC"
  | "style_ASC"
  | "style_DESC"
  | "content_ASC"
  | "content_DESC"
  | "order_ASC"
  | "order_DESC";

export type ProsAndConsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "order_ASC"
  | "order_DESC";

export type ProsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "order_ASC"
  | "order_DESC";

export type ConsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "order_ASC"
  | "order_DESC";

export type FaqCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "description_ASC"
  | "description_DESC";

export type PageStatus = "DRAFT" | "PUBLISHED" | "DELETED";

export type MediaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "title_ASC"
  | "title_DESC"
  | "altText_ASC"
  | "altText_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface ProsAndConsUpdateManyDataInput {
  title?: Maybe<String>;
  order?: Maybe<Int>;
}

export type AlertBoxWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AlertBoxUpdateManyMutationInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  prefix?: Maybe<String>;
  style?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface QuickTipWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  page?: Maybe<PageWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  buttonText?: Maybe<String>;
  buttonText_not?: Maybe<String>;
  buttonText_in?: Maybe<String[] | String>;
  buttonText_not_in?: Maybe<String[] | String>;
  buttonText_lt?: Maybe<String>;
  buttonText_lte?: Maybe<String>;
  buttonText_gt?: Maybe<String>;
  buttonText_gte?: Maybe<String>;
  buttonText_contains?: Maybe<String>;
  buttonText_not_contains?: Maybe<String>;
  buttonText_starts_with?: Maybe<String>;
  buttonText_not_starts_with?: Maybe<String>;
  buttonText_ends_with?: Maybe<String>;
  buttonText_not_ends_with?: Maybe<String>;
  buttonLink?: Maybe<String>;
  buttonLink_not?: Maybe<String>;
  buttonLink_in?: Maybe<String[] | String>;
  buttonLink_not_in?: Maybe<String[] | String>;
  buttonLink_lt?: Maybe<String>;
  buttonLink_lte?: Maybe<String>;
  buttonLink_gt?: Maybe<String>;
  buttonLink_gte?: Maybe<String>;
  buttonLink_contains?: Maybe<String>;
  buttonLink_not_contains?: Maybe<String>;
  buttonLink_starts_with?: Maybe<String>;
  buttonLink_not_starts_with?: Maybe<String>;
  buttonLink_ends_with?: Maybe<String>;
  buttonLink_not_ends_with?: Maybe<String>;
  media?: Maybe<MediaWhereInput>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<QuickTipWhereInput[] | QuickTipWhereInput>;
  OR?: Maybe<QuickTipWhereInput[] | QuickTipWhereInput>;
  NOT?: Maybe<QuickTipWhereInput[] | QuickTipWhereInput>;
}

export interface BlockScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  video?: Maybe<String>;
  video_not?: Maybe<String>;
  video_in?: Maybe<String[] | String>;
  video_not_in?: Maybe<String[] | String>;
  video_lt?: Maybe<String>;
  video_lte?: Maybe<String>;
  video_gt?: Maybe<String>;
  video_gte?: Maybe<String>;
  video_contains?: Maybe<String>;
  video_not_contains?: Maybe<String>;
  video_starts_with?: Maybe<String>;
  video_not_starts_with?: Maybe<String>;
  video_ends_with?: Maybe<String>;
  video_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<BlockScalarWhereInput[] | BlockScalarWhereInput>;
  OR?: Maybe<BlockScalarWhereInput[] | BlockScalarWhereInput>;
  NOT?: Maybe<BlockScalarWhereInput[] | BlockScalarWhereInput>;
}

export interface FaqCategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<FaqCategoryScalarWhereInput[] | FaqCategoryScalarWhereInput>;
  OR?: Maybe<FaqCategoryScalarWhereInput[] | FaqCategoryScalarWhereInput>;
  NOT?: Maybe<FaqCategoryScalarWhereInput[] | FaqCategoryScalarWhereInput>;
}

export interface BlockUpdateManyWithWhereNestedInput {
  where: BlockScalarWhereInput;
  data: BlockUpdateManyDataInput;
}

export interface AlertBoxWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  page?: Maybe<PageWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  prefix?: Maybe<String>;
  prefix_not?: Maybe<String>;
  prefix_in?: Maybe<String[] | String>;
  prefix_not_in?: Maybe<String[] | String>;
  prefix_lt?: Maybe<String>;
  prefix_lte?: Maybe<String>;
  prefix_gt?: Maybe<String>;
  prefix_gte?: Maybe<String>;
  prefix_contains?: Maybe<String>;
  prefix_not_contains?: Maybe<String>;
  prefix_starts_with?: Maybe<String>;
  prefix_not_starts_with?: Maybe<String>;
  prefix_ends_with?: Maybe<String>;
  prefix_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<AlertBoxWhereInput[] | AlertBoxWhereInput>;
  OR?: Maybe<AlertBoxWhereInput[] | AlertBoxWhereInput>;
  NOT?: Maybe<AlertBoxWhereInput[] | AlertBoxWhereInput>;
}

export interface BlockUpdateManyDataInput {
  title?: Maybe<String>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface BoxUpdateManyWithoutPageInput {
  create?: Maybe<BoxCreateWithoutPageInput[] | BoxCreateWithoutPageInput>;
  delete?: Maybe<BoxWhereUniqueInput[] | BoxWhereUniqueInput>;
  connect?: Maybe<BoxWhereUniqueInput[] | BoxWhereUniqueInput>;
  set?: Maybe<BoxWhereUniqueInput[] | BoxWhereUniqueInput>;
  disconnect?: Maybe<BoxWhereUniqueInput[] | BoxWhereUniqueInput>;
  update?: Maybe<
    | BoxUpdateWithWhereUniqueWithoutPageInput[]
    | BoxUpdateWithWhereUniqueWithoutPageInput
  >;
  upsert?: Maybe<
    | BoxUpsertWithWhereUniqueWithoutPageInput[]
    | BoxUpsertWithWhereUniqueWithoutPageInput
  >;
  deleteMany?: Maybe<BoxScalarWhereInput[] | BoxScalarWhereInput>;
  updateMany?: Maybe<
    BoxUpdateManyWithWhereNestedInput[] | BoxUpdateManyWithWhereNestedInput
  >;
}

export interface QuickTipSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuickTipWhereInput>;
  AND?: Maybe<
    QuickTipSubscriptionWhereInput[] | QuickTipSubscriptionWhereInput
  >;
  OR?: Maybe<QuickTipSubscriptionWhereInput[] | QuickTipSubscriptionWhereInput>;
  NOT?: Maybe<
    QuickTipSubscriptionWhereInput[] | QuickTipSubscriptionWhereInput
  >;
}

export interface BoxUpdateWithWhereUniqueWithoutPageInput {
  where: BoxWhereUniqueInput;
  data: BoxUpdateWithoutPageDataInput;
}

export interface ProsAndConsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProsAndConsWhereInput>;
  AND?: Maybe<
    ProsAndConsSubscriptionWhereInput[] | ProsAndConsSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProsAndConsSubscriptionWhereInput[] | ProsAndConsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProsAndConsSubscriptionWhereInput[] | ProsAndConsSubscriptionWhereInput
  >;
}

export interface BoxUpdateWithoutPageDataInput {
  title?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface BoxWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  page?: Maybe<PageWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  media?: Maybe<MediaWhereInput>;
  video?: Maybe<String>;
  video_not?: Maybe<String>;
  video_in?: Maybe<String[] | String>;
  video_not_in?: Maybe<String[] | String>;
  video_lt?: Maybe<String>;
  video_lte?: Maybe<String>;
  video_gt?: Maybe<String>;
  video_gte?: Maybe<String>;
  video_contains?: Maybe<String>;
  video_not_contains?: Maybe<String>;
  video_starts_with?: Maybe<String>;
  video_not_starts_with?: Maybe<String>;
  video_ends_with?: Maybe<String>;
  video_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<BoxWhereInput[] | BoxWhereInput>;
  OR?: Maybe<BoxWhereInput[] | BoxWhereInput>;
  NOT?: Maybe<BoxWhereInput[] | BoxWhereInput>;
}

export interface BoxUpsertWithWhereUniqueWithoutPageInput {
  where: BoxWhereUniqueInput;
  update: BoxUpdateWithoutPageDataInput;
  create: BoxCreateWithoutPageInput;
}

export interface MediaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MediaWhereInput>;
  AND?: Maybe<MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput>;
  OR?: Maybe<MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput>;
  NOT?: Maybe<MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput>;
}

export interface BoxScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  video?: Maybe<String>;
  video_not?: Maybe<String>;
  video_in?: Maybe<String[] | String>;
  video_not_in?: Maybe<String[] | String>;
  video_lt?: Maybe<String>;
  video_lte?: Maybe<String>;
  video_gt?: Maybe<String>;
  video_gte?: Maybe<String>;
  video_contains?: Maybe<String>;
  video_not_contains?: Maybe<String>;
  video_starts_with?: Maybe<String>;
  video_not_starts_with?: Maybe<String>;
  video_ends_with?: Maybe<String>;
  video_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<BoxScalarWhereInput[] | BoxScalarWhereInput>;
  OR?: Maybe<BoxScalarWhereInput[] | BoxScalarWhereInput>;
  NOT?: Maybe<BoxScalarWhereInput[] | BoxScalarWhereInput>;
}

export interface FaqSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FaqWhereInput>;
  AND?: Maybe<FaqSubscriptionWhereInput[] | FaqSubscriptionWhereInput>;
  OR?: Maybe<FaqSubscriptionWhereInput[] | FaqSubscriptionWhereInput>;
  NOT?: Maybe<FaqSubscriptionWhereInput[] | FaqSubscriptionWhereInput>;
}

export interface BoxUpdateManyWithWhereNestedInput {
  where: BoxScalarWhereInput;
  data: BoxUpdateManyDataInput;
}

export interface BoxSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BoxWhereInput>;
  AND?: Maybe<BoxSubscriptionWhereInput[] | BoxSubscriptionWhereInput>;
  OR?: Maybe<BoxSubscriptionWhereInput[] | BoxSubscriptionWhereInput>;
  NOT?: Maybe<BoxSubscriptionWhereInput[] | BoxSubscriptionWhereInput>;
}

export interface BoxUpdateManyDataInput {
  title?: Maybe<String>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface BlockSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BlockWhereInput>;
  AND?: Maybe<BlockSubscriptionWhereInput[] | BlockSubscriptionWhereInput>;
  OR?: Maybe<BlockSubscriptionWhereInput[] | BlockSubscriptionWhereInput>;
  NOT?: Maybe<BlockSubscriptionWhereInput[] | BlockSubscriptionWhereInput>;
}

export interface ProsAndConsUpdateManyWithoutPageInput {
  create?: Maybe<
    ProsAndConsCreateWithoutPageInput[] | ProsAndConsCreateWithoutPageInput
  >;
  delete?: Maybe<ProsAndConsWhereUniqueInput[] | ProsAndConsWhereUniqueInput>;
  connect?: Maybe<ProsAndConsWhereUniqueInput[] | ProsAndConsWhereUniqueInput>;
  set?: Maybe<ProsAndConsWhereUniqueInput[] | ProsAndConsWhereUniqueInput>;
  disconnect?: Maybe<
    ProsAndConsWhereUniqueInput[] | ProsAndConsWhereUniqueInput
  >;
  update?: Maybe<
    | ProsAndConsUpdateWithWhereUniqueWithoutPageInput[]
    | ProsAndConsUpdateWithWhereUniqueWithoutPageInput
  >;
  upsert?: Maybe<
    | ProsAndConsUpsertWithWhereUniqueWithoutPageInput[]
    | ProsAndConsUpsertWithWhereUniqueWithoutPageInput
  >;
  deleteMany?: Maybe<
    ProsAndConsScalarWhereInput[] | ProsAndConsScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProsAndConsUpdateManyWithWhereNestedInput[]
    | ProsAndConsUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
}

export interface ProsAndConsUpdateWithWhereUniqueWithoutPageInput {
  where: ProsAndConsWhereUniqueInput;
  data: ProsAndConsUpdateWithoutPageDataInput;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
}

export interface ProsAndConsUpdateWithoutPageDataInput {
  title?: Maybe<String>;
  order?: Maybe<Int>;
  pros?: Maybe<ProsUpdateManyWithoutProsAndConsInput>;
  cons?: Maybe<ConsUpdateManyWithoutProsAndConsInput>;
}

export interface PageUpsertWithoutQuickTipsInput {
  update: PageUpdateWithoutQuickTipsDataInput;
  create: PageCreateWithoutQuickTipsInput;
}

export interface ProsUpdateManyWithoutProsAndConsInput {
  create?: Maybe<
    ProsCreateWithoutProsAndConsInput[] | ProsCreateWithoutProsAndConsInput
  >;
  delete?: Maybe<ProsWhereUniqueInput[] | ProsWhereUniqueInput>;
  connect?: Maybe<ProsWhereUniqueInput[] | ProsWhereUniqueInput>;
  set?: Maybe<ProsWhereUniqueInput[] | ProsWhereUniqueInput>;
  disconnect?: Maybe<ProsWhereUniqueInput[] | ProsWhereUniqueInput>;
  update?: Maybe<
    | ProsUpdateWithWhereUniqueWithoutProsAndConsInput[]
    | ProsUpdateWithWhereUniqueWithoutProsAndConsInput
  >;
  upsert?: Maybe<
    | ProsUpsertWithWhereUniqueWithoutProsAndConsInput[]
    | ProsUpsertWithWhereUniqueWithoutProsAndConsInput
  >;
  deleteMany?: Maybe<ProsScalarWhereInput[] | ProsScalarWhereInput>;
  updateMany?: Maybe<
    ProsUpdateManyWithWhereNestedInput[] | ProsUpdateManyWithWhereNestedInput
  >;
}

export interface PageUpdateWithoutQuickTipsDataInput {
  title?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<PageType>;
  status?: Maybe<PageStatus>;
  vertical?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  blocks?: Maybe<BlockUpdateManyWithoutPageInput>;
  boxes?: Maybe<BoxUpdateManyWithoutPageInput>;
  prosAndCons?: Maybe<ProsAndConsUpdateManyWithoutPageInput>;
  alertBoxes?: Maybe<AlertBoxUpdateManyWithoutPageInput>;
}

export interface ProsUpdateWithWhereUniqueWithoutProsAndConsInput {
  where: ProsWhereUniqueInput;
  data: ProsUpdateWithoutProsAndConsDataInput;
}

export interface QuickTipUpdateInput {
  page?: Maybe<PageUpdateOneRequiredWithoutQuickTipsInput>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  buttonText?: Maybe<String>;
  buttonLink?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  order?: Maybe<Int>;
}

export interface ProsUpdateWithoutProsAndConsDataInput {
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface PageCreateWithoutQuickTipsInput {
  id?: Maybe<ID_Input>;
  title: String;
  slug: String;
  type: PageType;
  status: PageStatus;
  vertical?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  blocks?: Maybe<BlockCreateManyWithoutPageInput>;
  boxes?: Maybe<BoxCreateManyWithoutPageInput>;
  prosAndCons?: Maybe<ProsAndConsCreateManyWithoutPageInput>;
  alertBoxes?: Maybe<AlertBoxCreateManyWithoutPageInput>;
}

export interface ProsUpsertWithWhereUniqueWithoutProsAndConsInput {
  where: ProsWhereUniqueInput;
  update: ProsUpdateWithoutProsAndConsDataInput;
  create: ProsCreateWithoutProsAndConsInput;
}

export interface PageCreateOneWithoutQuickTipsInput {
  create?: Maybe<PageCreateWithoutQuickTipsInput>;
  connect?: Maybe<PageWhereUniqueInput>;
}

export interface ProsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<ProsScalarWhereInput[] | ProsScalarWhereInput>;
  OR?: Maybe<ProsScalarWhereInput[] | ProsScalarWhereInput>;
  NOT?: Maybe<ProsScalarWhereInput[] | ProsScalarWhereInput>;
}

export interface QuickTipCreateInput {
  id?: Maybe<ID_Input>;
  page: PageCreateOneWithoutQuickTipsInput;
  title?: Maybe<String>;
  content?: Maybe<String>;
  buttonText?: Maybe<String>;
  buttonLink?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  order?: Maybe<Int>;
}

export interface ProsUpdateManyWithWhereNestedInput {
  where: ProsScalarWhereInput;
  data: ProsUpdateManyDataInput;
}

export interface FaqCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  faqs_every?: Maybe<FaqWhereInput>;
  faqs_some?: Maybe<FaqWhereInput>;
  faqs_none?: Maybe<FaqWhereInput>;
  AND?: Maybe<FaqCategoryWhereInput[] | FaqCategoryWhereInput>;
  OR?: Maybe<FaqCategoryWhereInput[] | FaqCategoryWhereInput>;
  NOT?: Maybe<FaqCategoryWhereInput[] | FaqCategoryWhereInput>;
}

export interface ProsUpdateManyDataInput {
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface ProsAndConsUpdateManyMutationInput {
  title?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface ConsUpdateManyWithoutProsAndConsInput {
  create?: Maybe<
    ConsCreateWithoutProsAndConsInput[] | ConsCreateWithoutProsAndConsInput
  >;
  delete?: Maybe<ConsWhereUniqueInput[] | ConsWhereUniqueInput>;
  connect?: Maybe<ConsWhereUniqueInput[] | ConsWhereUniqueInput>;
  set?: Maybe<ConsWhereUniqueInput[] | ConsWhereUniqueInput>;
  disconnect?: Maybe<ConsWhereUniqueInput[] | ConsWhereUniqueInput>;
  update?: Maybe<
    | ConsUpdateWithWhereUniqueWithoutProsAndConsInput[]
    | ConsUpdateWithWhereUniqueWithoutProsAndConsInput
  >;
  upsert?: Maybe<
    | ConsUpsertWithWhereUniqueWithoutProsAndConsInput[]
    | ConsUpsertWithWhereUniqueWithoutProsAndConsInput
  >;
  deleteMany?: Maybe<ConsScalarWhereInput[] | ConsScalarWhereInput>;
  updateMany?: Maybe<
    ConsUpdateManyWithWhereNestedInput[] | ConsUpdateManyWithWhereNestedInput
  >;
}

export interface ProsAndConsUpdateInput {
  page?: Maybe<PageUpdateOneRequiredWithoutProsAndConsInput>;
  title?: Maybe<String>;
  order?: Maybe<Int>;
  pros?: Maybe<ProsUpdateManyWithoutProsAndConsInput>;
  cons?: Maybe<ConsUpdateManyWithoutProsAndConsInput>;
}

export interface ConsUpdateWithWhereUniqueWithoutProsAndConsInput {
  where: ConsWhereUniqueInput;
  data: ConsUpdateWithoutProsAndConsDataInput;
}

export interface ProsUpdateManyMutationInput {
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface ConsUpdateWithoutProsAndConsDataInput {
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface ProsAndConsUpdateWithoutProsDataInput {
  page?: Maybe<PageUpdateOneRequiredWithoutProsAndConsInput>;
  title?: Maybe<String>;
  order?: Maybe<Int>;
  cons?: Maybe<ConsUpdateManyWithoutProsAndConsInput>;
}

export interface ConsUpsertWithWhereUniqueWithoutProsAndConsInput {
  where: ConsWhereUniqueInput;
  update: ConsUpdateWithoutProsAndConsDataInput;
  create: ConsCreateWithoutProsAndConsInput;
}

export interface ProsAndConsUpdateOneRequiredWithoutProsInput {
  create?: Maybe<ProsAndConsCreateWithoutProsInput>;
  update?: Maybe<ProsAndConsUpdateWithoutProsDataInput>;
  upsert?: Maybe<ProsAndConsUpsertWithoutProsInput>;
  connect?: Maybe<ProsAndConsWhereUniqueInput>;
}

export interface ConsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<ConsScalarWhereInput[] | ConsScalarWhereInput>;
  OR?: Maybe<ConsScalarWhereInput[] | ConsScalarWhereInput>;
  NOT?: Maybe<ConsScalarWhereInput[] | ConsScalarWhereInput>;
}

export interface ProsAndConsCreateWithoutProsInput {
  id?: Maybe<ID_Input>;
  page: PageCreateOneWithoutProsAndConsInput;
  title?: Maybe<String>;
  order?: Maybe<Int>;
  cons?: Maybe<ConsCreateManyWithoutProsAndConsInput>;
}

export interface ConsUpdateManyWithWhereNestedInput {
  where: ConsScalarWhereInput;
  data: ConsUpdateManyDataInput;
}

export interface ProsAndConsCreateOneWithoutProsInput {
  create?: Maybe<ProsAndConsCreateWithoutProsInput>;
  connect?: Maybe<ProsAndConsWhereUniqueInput>;
}

export interface ConsUpdateManyDataInput {
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface PageUpdateManyMutationInput {
  title?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<PageType>;
  status?: Maybe<PageStatus>;
  vertical?: Maybe<String>;
}

export interface ProsAndConsUpsertWithWhereUniqueWithoutPageInput {
  where: ProsAndConsWhereUniqueInput;
  update: ProsAndConsUpdateWithoutPageDataInput;
  create: ProsAndConsCreateWithoutPageInput;
}

export type PageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProsAndConsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<ProsAndConsScalarWhereInput[] | ProsAndConsScalarWhereInput>;
  OR?: Maybe<ProsAndConsScalarWhereInput[] | ProsAndConsScalarWhereInput>;
  NOT?: Maybe<ProsAndConsScalarWhereInput[] | ProsAndConsScalarWhereInput>;
}

export interface MediaUpdateManyMutationInput {
  url?: Maybe<String>;
  title?: Maybe<String>;
  altText?: Maybe<String>;
}

export interface ProsAndConsUpdateManyWithWhereNestedInput {
  where: ProsAndConsScalarWhereInput;
  data: ProsAndConsUpdateManyDataInput;
}

export interface FaqCategoryUpdateManyMutationInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  description?: Maybe<String>;
}

export interface FaqUpdatetagInput {
  set?: Maybe<String[] | String>;
}

export interface FaqUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  short_description?: Maybe<String>;
  slug?: Maybe<String>;
  vertical?: Maybe<String>;
  readingTime?: Maybe<Int>;
  order?: Maybe<Int>;
  variant?: Maybe<FaqUpdatevariantInput>;
  tag?: Maybe<FaqUpdatetagInput>;
  pubDate?: Maybe<DateTimeInput>;
}

export interface QuickTipUpdateManyWithoutPageInput {
  create?: Maybe<
    QuickTipCreateWithoutPageInput[] | QuickTipCreateWithoutPageInput
  >;
  delete?: Maybe<QuickTipWhereUniqueInput[] | QuickTipWhereUniqueInput>;
  connect?: Maybe<QuickTipWhereUniqueInput[] | QuickTipWhereUniqueInput>;
  set?: Maybe<QuickTipWhereUniqueInput[] | QuickTipWhereUniqueInput>;
  disconnect?: Maybe<QuickTipWhereUniqueInput[] | QuickTipWhereUniqueInput>;
  update?: Maybe<
    | QuickTipUpdateWithWhereUniqueWithoutPageInput[]
    | QuickTipUpdateWithWhereUniqueWithoutPageInput
  >;
  upsert?: Maybe<
    | QuickTipUpsertWithWhereUniqueWithoutPageInput[]
    | QuickTipUpsertWithWhereUniqueWithoutPageInput
  >;
  deleteMany?: Maybe<QuickTipScalarWhereInput[] | QuickTipScalarWhereInput>;
  updateMany?: Maybe<
    | QuickTipUpdateManyWithWhereNestedInput[]
    | QuickTipUpdateManyWithWhereNestedInput
  >;
}

export interface FaqScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  short_description?: Maybe<String>;
  short_description_not?: Maybe<String>;
  short_description_in?: Maybe<String[] | String>;
  short_description_not_in?: Maybe<String[] | String>;
  short_description_lt?: Maybe<String>;
  short_description_lte?: Maybe<String>;
  short_description_gt?: Maybe<String>;
  short_description_gte?: Maybe<String>;
  short_description_contains?: Maybe<String>;
  short_description_not_contains?: Maybe<String>;
  short_description_starts_with?: Maybe<String>;
  short_description_not_starts_with?: Maybe<String>;
  short_description_ends_with?: Maybe<String>;
  short_description_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  vertical?: Maybe<String>;
  vertical_not?: Maybe<String>;
  vertical_in?: Maybe<String[] | String>;
  vertical_not_in?: Maybe<String[] | String>;
  vertical_lt?: Maybe<String>;
  vertical_lte?: Maybe<String>;
  vertical_gt?: Maybe<String>;
  vertical_gte?: Maybe<String>;
  vertical_contains?: Maybe<String>;
  vertical_not_contains?: Maybe<String>;
  vertical_starts_with?: Maybe<String>;
  vertical_not_starts_with?: Maybe<String>;
  vertical_ends_with?: Maybe<String>;
  vertical_not_ends_with?: Maybe<String>;
  readingTime?: Maybe<Int>;
  readingTime_not?: Maybe<Int>;
  readingTime_in?: Maybe<Int[] | Int>;
  readingTime_not_in?: Maybe<Int[] | Int>;
  readingTime_lt?: Maybe<Int>;
  readingTime_lte?: Maybe<Int>;
  readingTime_gt?: Maybe<Int>;
  readingTime_gte?: Maybe<Int>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  pubDate?: Maybe<DateTimeInput>;
  pubDate_not?: Maybe<DateTimeInput>;
  pubDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pubDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pubDate_lt?: Maybe<DateTimeInput>;
  pubDate_lte?: Maybe<DateTimeInput>;
  pubDate_gt?: Maybe<DateTimeInput>;
  pubDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FaqScalarWhereInput[] | FaqScalarWhereInput>;
  OR?: Maybe<FaqScalarWhereInput[] | FaqScalarWhereInput>;
  NOT?: Maybe<FaqScalarWhereInput[] | FaqScalarWhereInput>;
}

export interface QuickTipUpdateWithWhereUniqueWithoutPageInput {
  where: QuickTipWhereUniqueInput;
  data: QuickTipUpdateWithoutPageDataInput;
}

export interface FaqUpsertWithWhereUniqueWithoutCategoryInput {
  where: FaqWhereUniqueInput;
  update: FaqUpdateWithoutCategoryDataInput;
  create: FaqCreateWithoutCategoryInput;
}

export interface QuickTipUpdateWithoutPageDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  buttonText?: Maybe<String>;
  buttonLink?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  order?: Maybe<Int>;
}

export interface FaqUpdateWithWhereUniqueWithoutCategoryInput {
  where: FaqWhereUniqueInput;
  data: FaqUpdateWithoutCategoryDataInput;
}

export interface QuickTipUpsertWithWhereUniqueWithoutPageInput {
  where: QuickTipWhereUniqueInput;
  update: QuickTipUpdateWithoutPageDataInput;
  create: QuickTipCreateWithoutPageInput;
}

export interface FaqUpdateManyWithoutCategoryInput {
  create?: Maybe<
    FaqCreateWithoutCategoryInput[] | FaqCreateWithoutCategoryInput
  >;
  delete?: Maybe<FaqWhereUniqueInput[] | FaqWhereUniqueInput>;
  connect?: Maybe<FaqWhereUniqueInput[] | FaqWhereUniqueInput>;
  set?: Maybe<FaqWhereUniqueInput[] | FaqWhereUniqueInput>;
  disconnect?: Maybe<FaqWhereUniqueInput[] | FaqWhereUniqueInput>;
  update?: Maybe<
    | FaqUpdateWithWhereUniqueWithoutCategoryInput[]
    | FaqUpdateWithWhereUniqueWithoutCategoryInput
  >;
  upsert?: Maybe<
    | FaqUpsertWithWhereUniqueWithoutCategoryInput[]
    | FaqUpsertWithWhereUniqueWithoutCategoryInput
  >;
  deleteMany?: Maybe<FaqScalarWhereInput[] | FaqScalarWhereInput>;
  updateMany?: Maybe<
    FaqUpdateManyWithWhereNestedInput[] | FaqUpdateManyWithWhereNestedInput
  >;
}

export interface QuickTipScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  buttonText?: Maybe<String>;
  buttonText_not?: Maybe<String>;
  buttonText_in?: Maybe<String[] | String>;
  buttonText_not_in?: Maybe<String[] | String>;
  buttonText_lt?: Maybe<String>;
  buttonText_lte?: Maybe<String>;
  buttonText_gt?: Maybe<String>;
  buttonText_gte?: Maybe<String>;
  buttonText_contains?: Maybe<String>;
  buttonText_not_contains?: Maybe<String>;
  buttonText_starts_with?: Maybe<String>;
  buttonText_not_starts_with?: Maybe<String>;
  buttonText_ends_with?: Maybe<String>;
  buttonText_not_ends_with?: Maybe<String>;
  buttonLink?: Maybe<String>;
  buttonLink_not?: Maybe<String>;
  buttonLink_in?: Maybe<String[] | String>;
  buttonLink_not_in?: Maybe<String[] | String>;
  buttonLink_lt?: Maybe<String>;
  buttonLink_lte?: Maybe<String>;
  buttonLink_gt?: Maybe<String>;
  buttonLink_gte?: Maybe<String>;
  buttonLink_contains?: Maybe<String>;
  buttonLink_not_contains?: Maybe<String>;
  buttonLink_starts_with?: Maybe<String>;
  buttonLink_not_starts_with?: Maybe<String>;
  buttonLink_ends_with?: Maybe<String>;
  buttonLink_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<QuickTipScalarWhereInput[] | QuickTipScalarWhereInput>;
  OR?: Maybe<QuickTipScalarWhereInput[] | QuickTipScalarWhereInput>;
  NOT?: Maybe<QuickTipScalarWhereInput[] | QuickTipScalarWhereInput>;
}

export interface FaqCreateWithoutCategoryInput {
  id?: Maybe<ID_Input>;
  title: String;
  description?: Maybe<String>;
  short_description?: Maybe<String>;
  authors?: Maybe<UserCreateManyInput>;
  slug: String;
  vertical?: Maybe<String>;
  readingTime?: Maybe<Int>;
  order?: Maybe<Int>;
  variant?: Maybe<FaqCreatevariantInput>;
  tag?: Maybe<FaqCreatetagInput>;
  pubDate?: Maybe<DateTimeInput>;
}

export interface QuickTipUpdateManyWithWhereNestedInput {
  where: QuickTipScalarWhereInput;
  data: QuickTipUpdateManyDataInput;
}

export interface FaqCreateManyWithoutCategoryInput {
  create?: Maybe<
    FaqCreateWithoutCategoryInput[] | FaqCreateWithoutCategoryInput
  >;
  connect?: Maybe<FaqWhereUniqueInput[] | FaqWhereUniqueInput>;
}

export interface QuickTipUpdateManyDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  buttonText?: Maybe<String>;
  buttonLink?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface FaqUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  short_description?: Maybe<String>;
  slug?: Maybe<String>;
  vertical?: Maybe<String>;
  readingTime?: Maybe<Int>;
  order?: Maybe<Int>;
  variant?: Maybe<FaqUpdatevariantInput>;
  tag?: Maybe<FaqUpdatetagInput>;
  pubDate?: Maybe<DateTimeInput>;
}

export interface PageUpsertWithoutAlertBoxesInput {
  update: PageUpdateWithoutAlertBoxesDataInput;
  create: PageCreateWithoutAlertBoxesInput;
}

export interface AlertBoxCreateInput {
  id?: Maybe<ID_Input>;
  page: PageCreateOneWithoutAlertBoxesInput;
  title?: Maybe<String>;
  content?: Maybe<String>;
  prefix?: Maybe<String>;
  style?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface FaqUpdatevariantInput {
  set?: Maybe<String[] | String>;
}

export interface PageCreateWithoutAlertBoxesInput {
  id?: Maybe<ID_Input>;
  title: String;
  slug: String;
  type: PageType;
  status: PageStatus;
  vertical?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  blocks?: Maybe<BlockCreateManyWithoutPageInput>;
  boxes?: Maybe<BoxCreateManyWithoutPageInput>;
  prosAndCons?: Maybe<ProsAndConsCreateManyWithoutPageInput>;
  quickTips?: Maybe<QuickTipCreateManyWithoutPageInput>;
}

export interface FaqCategoryUpdateManyDataInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  description?: Maybe<String>;
}

export interface MediaCreateInput {
  id?: Maybe<ID_Input>;
  url: String;
  title?: Maybe<String>;
  altText?: Maybe<String>;
}

export interface FaqCategoryUpdateManyWithWhereNestedInput {
  where: FaqCategoryScalarWhereInput;
  data: FaqCategoryUpdateManyDataInput;
}

export interface BlockCreateWithoutPageInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface BlockCreateInput {
  id?: Maybe<ID_Input>;
  page: PageCreateOneWithoutBlocksInput;
  title?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface BoxCreateWithoutPageInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface PageCreateOneWithoutBlocksInput {
  create?: Maybe<PageCreateWithoutBlocksInput>;
  connect?: Maybe<PageWhereUniqueInput>;
}

export interface ProsAndConsCreateWithoutPageInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  order?: Maybe<Int>;
  pros?: Maybe<ProsCreateManyWithoutProsAndConsInput>;
  cons?: Maybe<ConsCreateManyWithoutProsAndConsInput>;
}

export interface PageCreateWithoutBlocksInput {
  id?: Maybe<ID_Input>;
  title: String;
  slug: String;
  type: PageType;
  status: PageStatus;
  vertical?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  boxes?: Maybe<BoxCreateManyWithoutPageInput>;
  prosAndCons?: Maybe<ProsAndConsCreateManyWithoutPageInput>;
  alertBoxes?: Maybe<AlertBoxCreateManyWithoutPageInput>;
  quickTips?: Maybe<QuickTipCreateManyWithoutPageInput>;
}

export interface ProsCreateWithoutProsAndConsInput {
  id?: Maybe<ID_Input>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface AlertBoxCreateManyWithoutPageInput {
  create?: Maybe<
    AlertBoxCreateWithoutPageInput[] | AlertBoxCreateWithoutPageInput
  >;
  connect?: Maybe<AlertBoxWhereUniqueInput[] | AlertBoxWhereUniqueInput>;
}

export interface ConsCreateWithoutProsAndConsInput {
  id?: Maybe<ID_Input>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface AlertBoxCreateWithoutPageInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  prefix?: Maybe<String>;
  style?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface QuickTipCreateWithoutPageInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  buttonText?: Maybe<String>;
  buttonLink?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  order?: Maybe<Int>;
}

export interface BlockUpdateInput {
  page?: Maybe<PageUpdateOneRequiredWithoutBlocksInput>;
  title?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface PageUpdateOneRequiredWithoutAlertBoxesInput {
  create?: Maybe<PageCreateWithoutAlertBoxesInput>;
  update?: Maybe<PageUpdateWithoutAlertBoxesDataInput>;
  upsert?: Maybe<PageUpsertWithoutAlertBoxesInput>;
  connect?: Maybe<PageWhereUniqueInput>;
}

export interface PageUpdateOneRequiredWithoutBlocksInput {
  create?: Maybe<PageCreateWithoutBlocksInput>;
  update?: Maybe<PageUpdateWithoutBlocksDataInput>;
  upsert?: Maybe<PageUpsertWithoutBlocksInput>;
  connect?: Maybe<PageWhereUniqueInput>;
}

export interface MediaUpdateOneInput {
  create?: Maybe<MediaCreateInput>;
  update?: Maybe<MediaUpdateDataInput>;
  upsert?: Maybe<MediaUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MediaWhereUniqueInput>;
}

export interface PageUpdateWithoutBlocksDataInput {
  title?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<PageType>;
  status?: Maybe<PageStatus>;
  vertical?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  boxes?: Maybe<BoxUpdateManyWithoutPageInput>;
  prosAndCons?: Maybe<ProsAndConsUpdateManyWithoutPageInput>;
  alertBoxes?: Maybe<AlertBoxUpdateManyWithoutPageInput>;
  quickTips?: Maybe<QuickTipUpdateManyWithoutPageInput>;
}

export interface MediaUpsertNestedInput {
  update: MediaUpdateDataInput;
  create: MediaCreateInput;
}

export interface AlertBoxUpdateManyWithoutPageInput {
  create?: Maybe<
    AlertBoxCreateWithoutPageInput[] | AlertBoxCreateWithoutPageInput
  >;
  delete?: Maybe<AlertBoxWhereUniqueInput[] | AlertBoxWhereUniqueInput>;
  connect?: Maybe<AlertBoxWhereUniqueInput[] | AlertBoxWhereUniqueInput>;
  set?: Maybe<AlertBoxWhereUniqueInput[] | AlertBoxWhereUniqueInput>;
  disconnect?: Maybe<AlertBoxWhereUniqueInput[] | AlertBoxWhereUniqueInput>;
  update?: Maybe<
    | AlertBoxUpdateWithWhereUniqueWithoutPageInput[]
    | AlertBoxUpdateWithWhereUniqueWithoutPageInput
  >;
  upsert?: Maybe<
    | AlertBoxUpsertWithWhereUniqueWithoutPageInput[]
    | AlertBoxUpsertWithWhereUniqueWithoutPageInput
  >;
  deleteMany?: Maybe<AlertBoxScalarWhereInput[] | AlertBoxScalarWhereInput>;
  updateMany?: Maybe<
    | AlertBoxUpdateManyWithWhereNestedInput[]
    | AlertBoxUpdateManyWithWhereNestedInput
  >;
}

export interface BlockUpdateWithWhereUniqueWithoutPageInput {
  where: BlockWhereUniqueInput;
  data: BlockUpdateWithoutPageDataInput;
}

export interface AlertBoxUpdateWithWhereUniqueWithoutPageInput {
  where: AlertBoxWhereUniqueInput;
  data: AlertBoxUpdateWithoutPageDataInput;
}

export interface BlockUpsertWithWhereUniqueWithoutPageInput {
  where: BlockWhereUniqueInput;
  update: BlockUpdateWithoutPageDataInput;
  create: BlockCreateWithoutPageInput;
}

export interface AlertBoxUpdateWithoutPageDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  prefix?: Maybe<String>;
  style?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface ProsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  prosAndCons?: Maybe<ProsAndConsWhereInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<ProsWhereInput[] | ProsWhereInput>;
  OR?: Maybe<ProsWhereInput[] | ProsWhereInput>;
  NOT?: Maybe<ProsWhereInput[] | ProsWhereInput>;
}

export interface AlertBoxUpsertWithWhereUniqueWithoutPageInput {
  where: AlertBoxWhereUniqueInput;
  update: AlertBoxUpdateWithoutPageDataInput;
  create: AlertBoxCreateWithoutPageInput;
}

export interface ProsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProsWhereInput>;
  AND?: Maybe<ProsSubscriptionWhereInput[] | ProsSubscriptionWhereInput>;
  OR?: Maybe<ProsSubscriptionWhereInput[] | ProsSubscriptionWhereInput>;
  NOT?: Maybe<ProsSubscriptionWhereInput[] | ProsSubscriptionWhereInput>;
}

export interface AlertBoxScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  prefix?: Maybe<String>;
  prefix_not?: Maybe<String>;
  prefix_in?: Maybe<String[] | String>;
  prefix_not_in?: Maybe<String[] | String>;
  prefix_lt?: Maybe<String>;
  prefix_lte?: Maybe<String>;
  prefix_gt?: Maybe<String>;
  prefix_gte?: Maybe<String>;
  prefix_contains?: Maybe<String>;
  prefix_not_contains?: Maybe<String>;
  prefix_starts_with?: Maybe<String>;
  prefix_not_starts_with?: Maybe<String>;
  prefix_ends_with?: Maybe<String>;
  prefix_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<AlertBoxScalarWhereInput[] | AlertBoxScalarWhereInput>;
  OR?: Maybe<AlertBoxScalarWhereInput[] | AlertBoxScalarWhereInput>;
  NOT?: Maybe<AlertBoxScalarWhereInput[] | AlertBoxScalarWhereInput>;
}

export interface FaqCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FaqCategoryWhereInput>;
  AND?: Maybe<
    FaqCategorySubscriptionWhereInput[] | FaqCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    FaqCategorySubscriptionWhereInput[] | FaqCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    FaqCategorySubscriptionWhereInput[] | FaqCategorySubscriptionWhereInput
  >;
}

export interface AlertBoxUpdateManyWithWhereNestedInput {
  where: AlertBoxScalarWhereInput;
  data: AlertBoxUpdateManyDataInput;
}

export type BlockWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AlertBoxUpdateManyDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  prefix?: Maybe<String>;
  style?: Maybe<String>;
  order?: Maybe<Int>;
}

export type BoxWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PageUpsertWithoutBlocksInput {
  update: PageUpdateWithoutBlocksDataInput;
  create: PageCreateWithoutBlocksInput;
}

export type ConsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BlockUpdateManyMutationInput {
  title?: Maybe<String>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export type FaqWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BoxCreateInput {
  id?: Maybe<ID_Input>;
  page: PageCreateOneWithoutBoxesInput;
  title?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface MediaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  altText?: Maybe<String>;
  altText_not?: Maybe<String>;
  altText_in?: Maybe<String[] | String>;
  altText_not_in?: Maybe<String[] | String>;
  altText_lt?: Maybe<String>;
  altText_lte?: Maybe<String>;
  altText_gt?: Maybe<String>;
  altText_gte?: Maybe<String>;
  altText_contains?: Maybe<String>;
  altText_not_contains?: Maybe<String>;
  altText_starts_with?: Maybe<String>;
  altText_not_starts_with?: Maybe<String>;
  altText_ends_with?: Maybe<String>;
  altText_not_ends_with?: Maybe<String>;
  AND?: Maybe<MediaWhereInput[] | MediaWhereInput>;
  OR?: Maybe<MediaWhereInput[] | MediaWhereInput>;
  NOT?: Maybe<MediaWhereInput[] | MediaWhereInput>;
}

export interface PageCreateOneWithoutBoxesInput {
  create?: Maybe<PageCreateWithoutBoxesInput>;
  connect?: Maybe<PageWhereUniqueInput>;
}

export interface FaqWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  short_description?: Maybe<String>;
  short_description_not?: Maybe<String>;
  short_description_in?: Maybe<String[] | String>;
  short_description_not_in?: Maybe<String[] | String>;
  short_description_lt?: Maybe<String>;
  short_description_lte?: Maybe<String>;
  short_description_gt?: Maybe<String>;
  short_description_gte?: Maybe<String>;
  short_description_contains?: Maybe<String>;
  short_description_not_contains?: Maybe<String>;
  short_description_starts_with?: Maybe<String>;
  short_description_not_starts_with?: Maybe<String>;
  short_description_ends_with?: Maybe<String>;
  short_description_not_ends_with?: Maybe<String>;
  authors_every?: Maybe<UserWhereInput>;
  authors_some?: Maybe<UserWhereInput>;
  authors_none?: Maybe<UserWhereInput>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  vertical?: Maybe<String>;
  vertical_not?: Maybe<String>;
  vertical_in?: Maybe<String[] | String>;
  vertical_not_in?: Maybe<String[] | String>;
  vertical_lt?: Maybe<String>;
  vertical_lte?: Maybe<String>;
  vertical_gt?: Maybe<String>;
  vertical_gte?: Maybe<String>;
  vertical_contains?: Maybe<String>;
  vertical_not_contains?: Maybe<String>;
  vertical_starts_with?: Maybe<String>;
  vertical_not_starts_with?: Maybe<String>;
  vertical_ends_with?: Maybe<String>;
  vertical_not_ends_with?: Maybe<String>;
  category_every?: Maybe<FaqCategoryWhereInput>;
  category_some?: Maybe<FaqCategoryWhereInput>;
  category_none?: Maybe<FaqCategoryWhereInput>;
  readingTime?: Maybe<Int>;
  readingTime_not?: Maybe<Int>;
  readingTime_in?: Maybe<Int[] | Int>;
  readingTime_not_in?: Maybe<Int[] | Int>;
  readingTime_lt?: Maybe<Int>;
  readingTime_lte?: Maybe<Int>;
  readingTime_gt?: Maybe<Int>;
  readingTime_gte?: Maybe<Int>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  pubDate?: Maybe<DateTimeInput>;
  pubDate_not?: Maybe<DateTimeInput>;
  pubDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pubDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pubDate_lt?: Maybe<DateTimeInput>;
  pubDate_lte?: Maybe<DateTimeInput>;
  pubDate_gt?: Maybe<DateTimeInput>;
  pubDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FaqWhereInput[] | FaqWhereInput>;
  OR?: Maybe<FaqWhereInput[] | FaqWhereInput>;
  NOT?: Maybe<FaqWhereInput[] | FaqWhereInput>;
}

export interface PageCreateWithoutBoxesInput {
  id?: Maybe<ID_Input>;
  title: String;
  slug: String;
  type: PageType;
  status: PageStatus;
  vertical?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  blocks?: Maybe<BlockCreateManyWithoutPageInput>;
  prosAndCons?: Maybe<ProsAndConsCreateManyWithoutPageInput>;
  alertBoxes?: Maybe<AlertBoxCreateManyWithoutPageInput>;
  quickTips?: Maybe<QuickTipCreateManyWithoutPageInput>;
}

export interface ProsAndConsCreateInput {
  id?: Maybe<ID_Input>;
  page: PageCreateOneWithoutProsAndConsInput;
  title?: Maybe<String>;
  order?: Maybe<Int>;
  pros?: Maybe<ProsCreateManyWithoutProsAndConsInput>;
  cons?: Maybe<ConsCreateManyWithoutProsAndConsInput>;
}

export interface BoxUpdateInput {
  page?: Maybe<PageUpdateOneRequiredWithoutBoxesInput>;
  title?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export type FaqCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PageUpdateOneRequiredWithoutBoxesInput {
  create?: Maybe<PageCreateWithoutBoxesInput>;
  update?: Maybe<PageUpdateWithoutBoxesDataInput>;
  upsert?: Maybe<PageUpsertWithoutBoxesInput>;
  connect?: Maybe<PageWhereUniqueInput>;
}

export type MediaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PageUpdateWithoutBoxesDataInput {
  title?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<PageType>;
  status?: Maybe<PageStatus>;
  vertical?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  blocks?: Maybe<BlockUpdateManyWithoutPageInput>;
  prosAndCons?: Maybe<ProsAndConsUpdateManyWithoutPageInput>;
  alertBoxes?: Maybe<AlertBoxUpdateManyWithoutPageInput>;
  quickTips?: Maybe<QuickTipUpdateManyWithoutPageInput>;
}

export interface PageUpdateInput {
  title?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<PageType>;
  status?: Maybe<PageStatus>;
  vertical?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  blocks?: Maybe<BlockUpdateManyWithoutPageInput>;
  boxes?: Maybe<BoxUpdateManyWithoutPageInput>;
  prosAndCons?: Maybe<ProsAndConsUpdateManyWithoutPageInput>;
  alertBoxes?: Maybe<AlertBoxUpdateManyWithoutPageInput>;
  quickTips?: Maybe<QuickTipUpdateManyWithoutPageInput>;
}

export interface PageUpsertWithoutBoxesInput {
  update: PageUpdateWithoutBoxesDataInput;
  create: PageCreateWithoutBoxesInput;
}

export interface MediaUpdateInput {
  url?: Maybe<String>;
  title?: Maybe<String>;
  altText?: Maybe<String>;
}

export interface BoxUpdateManyMutationInput {
  title?: Maybe<String>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface FaqUpdateManyWithWhereNestedInput {
  where: FaqScalarWhereInput;
  data: FaqUpdateManyDataInput;
}

export interface ConsCreateInput {
  id?: Maybe<ID_Input>;
  prosAndCons: ProsAndConsCreateOneWithoutConsInput;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface FaqUpdateWithoutCategoryDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  short_description?: Maybe<String>;
  authors?: Maybe<UserUpdateManyInput>;
  slug?: Maybe<String>;
  vertical?: Maybe<String>;
  readingTime?: Maybe<Int>;
  order?: Maybe<Int>;
  variant?: Maybe<FaqUpdatevariantInput>;
  tag?: Maybe<FaqUpdatetagInput>;
  pubDate?: Maybe<DateTimeInput>;
}

export interface ProsAndConsCreateOneWithoutConsInput {
  create?: Maybe<ProsAndConsCreateWithoutConsInput>;
  connect?: Maybe<ProsAndConsWhereUniqueInput>;
}

export interface FaqCategoryUpdateInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  description?: Maybe<String>;
  faqs?: Maybe<FaqUpdateManyWithoutCategoryInput>;
}

export interface ProsAndConsCreateWithoutConsInput {
  id?: Maybe<ID_Input>;
  page: PageCreateOneWithoutProsAndConsInput;
  title?: Maybe<String>;
  order?: Maybe<Int>;
  pros?: Maybe<ProsCreateManyWithoutProsAndConsInput>;
}

export interface FaqCategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  slug: String;
  description: String;
  faqs?: Maybe<FaqCreateManyWithoutCategoryInput>;
}

export interface PageCreateOneWithoutProsAndConsInput {
  create?: Maybe<PageCreateWithoutProsAndConsInput>;
  connect?: Maybe<PageWhereUniqueInput>;
}

export interface PageCreateOneWithoutAlertBoxesInput {
  create?: Maybe<PageCreateWithoutAlertBoxesInput>;
  connect?: Maybe<PageWhereUniqueInput>;
}

export interface PageCreateWithoutProsAndConsInput {
  id?: Maybe<ID_Input>;
  title: String;
  slug: String;
  type: PageType;
  status: PageStatus;
  vertical?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  blocks?: Maybe<BlockCreateManyWithoutPageInput>;
  boxes?: Maybe<BoxCreateManyWithoutPageInput>;
  alertBoxes?: Maybe<AlertBoxCreateManyWithoutPageInput>;
  quickTips?: Maybe<QuickTipCreateManyWithoutPageInput>;
}

export interface BlockCreateManyWithoutPageInput {
  create?: Maybe<BlockCreateWithoutPageInput[] | BlockCreateWithoutPageInput>;
  connect?: Maybe<BlockWhereUniqueInput[] | BlockWhereUniqueInput>;
}

export interface ConsUpdateInput {
  prosAndCons?: Maybe<ProsAndConsUpdateOneRequiredWithoutConsInput>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface ProsAndConsCreateManyWithoutPageInput {
  create?: Maybe<
    ProsAndConsCreateWithoutPageInput[] | ProsAndConsCreateWithoutPageInput
  >;
  connect?: Maybe<ProsAndConsWhereUniqueInput[] | ProsAndConsWhereUniqueInput>;
}

export interface ProsAndConsUpdateOneRequiredWithoutConsInput {
  create?: Maybe<ProsAndConsCreateWithoutConsInput>;
  update?: Maybe<ProsAndConsUpdateWithoutConsDataInput>;
  upsert?: Maybe<ProsAndConsUpsertWithoutConsInput>;
  connect?: Maybe<ProsAndConsWhereUniqueInput>;
}

export interface ConsCreateManyWithoutProsAndConsInput {
  create?: Maybe<
    ConsCreateWithoutProsAndConsInput[] | ConsCreateWithoutProsAndConsInput
  >;
  connect?: Maybe<ConsWhereUniqueInput[] | ConsWhereUniqueInput>;
}

export interface ProsAndConsUpdateWithoutConsDataInput {
  page?: Maybe<PageUpdateOneRequiredWithoutProsAndConsInput>;
  title?: Maybe<String>;
  order?: Maybe<Int>;
  pros?: Maybe<ProsUpdateManyWithoutProsAndConsInput>;
}

export interface AlertBoxUpdateInput {
  page?: Maybe<PageUpdateOneRequiredWithoutAlertBoxesInput>;
  title?: Maybe<String>;
  content?: Maybe<String>;
  prefix?: Maybe<String>;
  style?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface PageUpdateOneRequiredWithoutProsAndConsInput {
  create?: Maybe<PageCreateWithoutProsAndConsInput>;
  update?: Maybe<PageUpdateWithoutProsAndConsDataInput>;
  upsert?: Maybe<PageUpsertWithoutProsAndConsInput>;
  connect?: Maybe<PageWhereUniqueInput>;
}

export interface MediaUpdateDataInput {
  url?: Maybe<String>;
  title?: Maybe<String>;
  altText?: Maybe<String>;
}

export interface PageUpdateWithoutProsAndConsDataInput {
  title?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<PageType>;
  status?: Maybe<PageStatus>;
  vertical?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  blocks?: Maybe<BlockUpdateManyWithoutPageInput>;
  boxes?: Maybe<BoxUpdateManyWithoutPageInput>;
  alertBoxes?: Maybe<AlertBoxUpdateManyWithoutPageInput>;
  quickTips?: Maybe<QuickTipUpdateManyWithoutPageInput>;
}

export interface BlockUpdateWithoutPageDataInput {
  title?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  video?: Maybe<String>;
  style?: Maybe<String>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface PageUpsertWithoutProsAndConsInput {
  update: PageUpdateWithoutProsAndConsDataInput;
  create: PageCreateWithoutProsAndConsInput;
}

export interface ProsAndConsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  page?: Maybe<PageWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  pros_every?: Maybe<ProsWhereInput>;
  pros_some?: Maybe<ProsWhereInput>;
  pros_none?: Maybe<ProsWhereInput>;
  cons_every?: Maybe<ConsWhereInput>;
  cons_some?: Maybe<ConsWhereInput>;
  cons_none?: Maybe<ConsWhereInput>;
  AND?: Maybe<ProsAndConsWhereInput[] | ProsAndConsWhereInput>;
  OR?: Maybe<ProsAndConsWhereInput[] | ProsAndConsWhereInput>;
  NOT?: Maybe<ProsAndConsWhereInput[] | ProsAndConsWhereInput>;
}

export interface ProsAndConsUpsertWithoutConsInput {
  update: ProsAndConsUpdateWithoutConsDataInput;
  create: ProsAndConsCreateWithoutConsInput;
}

export interface ConsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ConsWhereInput>;
  AND?: Maybe<ConsSubscriptionWhereInput[] | ConsSubscriptionWhereInput>;
  OR?: Maybe<ConsSubscriptionWhereInput[] | ConsSubscriptionWhereInput>;
  NOT?: Maybe<ConsSubscriptionWhereInput[] | ConsSubscriptionWhereInput>;
}

export interface ConsUpdateManyMutationInput {
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface QuickTipUpdateManyMutationInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  buttonText?: Maybe<String>;
  buttonLink?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface FaqCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description?: Maybe<String>;
  short_description?: Maybe<String>;
  authors?: Maybe<UserCreateManyInput>;
  slug: String;
  vertical?: Maybe<String>;
  category?: Maybe<FaqCategoryCreateManyWithoutFaqsInput>;
  readingTime?: Maybe<Int>;
  order?: Maybe<Int>;
  variant?: Maybe<FaqCreatevariantInput>;
  tag?: Maybe<FaqCreatetagInput>;
  pubDate?: Maybe<DateTimeInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface BlockWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  page?: Maybe<PageWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  media?: Maybe<MediaWhereInput>;
  video?: Maybe<String>;
  video_not?: Maybe<String>;
  video_in?: Maybe<String[] | String>;
  video_not_in?: Maybe<String[] | String>;
  video_lt?: Maybe<String>;
  video_lte?: Maybe<String>;
  video_gt?: Maybe<String>;
  video_gte?: Maybe<String>;
  video_contains?: Maybe<String>;
  video_not_contains?: Maybe<String>;
  video_starts_with?: Maybe<String>;
  video_not_starts_with?: Maybe<String>;
  video_ends_with?: Maybe<String>;
  video_not_ends_with?: Maybe<String>;
  style?: Maybe<String>;
  style_not?: Maybe<String>;
  style_in?: Maybe<String[] | String>;
  style_not_in?: Maybe<String[] | String>;
  style_lt?: Maybe<String>;
  style_lte?: Maybe<String>;
  style_gt?: Maybe<String>;
  style_gte?: Maybe<String>;
  style_contains?: Maybe<String>;
  style_not_contains?: Maybe<String>;
  style_starts_with?: Maybe<String>;
  style_not_starts_with?: Maybe<String>;
  style_ends_with?: Maybe<String>;
  style_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<BlockWhereInput[] | BlockWhereInput>;
  OR?: Maybe<BlockWhereInput[] | BlockWhereInput>;
  NOT?: Maybe<BlockWhereInput[] | BlockWhereInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  permissions?: Maybe<UserCreatepermissionsInput>;
}

export interface ProsUpdateInput {
  prosAndCons?: Maybe<ProsAndConsUpdateOneRequiredWithoutProsInput>;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface UserCreatepermissionsInput {
  set?: Maybe<Permission[] | Permission>;
}

export interface PageCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  slug: String;
  type: PageType;
  status: PageStatus;
  vertical?: Maybe<String>;
  media?: Maybe<MediaCreateOneInput>;
  blocks?: Maybe<BlockCreateManyWithoutPageInput>;
  boxes?: Maybe<BoxCreateManyWithoutPageInput>;
  prosAndCons?: Maybe<ProsAndConsCreateManyWithoutPageInput>;
  alertBoxes?: Maybe<AlertBoxCreateManyWithoutPageInput>;
  quickTips?: Maybe<QuickTipCreateManyWithoutPageInput>;
}

export interface FaqCategoryCreateManyWithoutFaqsInput {
  create?: Maybe<
    FaqCategoryCreateWithoutFaqsInput[] | FaqCategoryCreateWithoutFaqsInput
  >;
  connect?: Maybe<FaqCategoryWhereUniqueInput[] | FaqCategoryWhereUniqueInput>;
}

export type ProsAndConsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FaqCategoryCreateWithoutFaqsInput {
  id?: Maybe<ID_Input>;
  name: String;
  slug: String;
  description: String;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface FaqCreatevariantInput {
  set?: Maybe<String[] | String>;
}

export interface MediaCreateOneInput {
  create?: Maybe<MediaCreateInput>;
  connect?: Maybe<MediaWhereUniqueInput>;
}

export interface FaqCreatetagInput {
  set?: Maybe<String[] | String>;
}

export interface ProsCreateManyWithoutProsAndConsInput {
  create?: Maybe<
    ProsCreateWithoutProsAndConsInput[] | ProsCreateWithoutProsAndConsInput
  >;
  connect?: Maybe<ProsWhereUniqueInput[] | ProsWhereUniqueInput>;
}

export interface FaqUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  short_description?: Maybe<String>;
  authors?: Maybe<UserUpdateManyInput>;
  slug?: Maybe<String>;
  vertical?: Maybe<String>;
  category?: Maybe<FaqCategoryUpdateManyWithoutFaqsInput>;
  readingTime?: Maybe<Int>;
  order?: Maybe<Int>;
  variant?: Maybe<FaqUpdatevariantInput>;
  tag?: Maybe<FaqUpdatetagInput>;
  pubDate?: Maybe<DateTimeInput>;
}

export interface PageUpdateWithoutAlertBoxesDataInput {
  title?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<PageType>;
  status?: Maybe<PageStatus>;
  vertical?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  blocks?: Maybe<BlockUpdateManyWithoutPageInput>;
  boxes?: Maybe<BoxUpdateManyWithoutPageInput>;
  prosAndCons?: Maybe<ProsAndConsUpdateManyWithoutPageInput>;
  quickTips?: Maybe<QuickTipUpdateManyWithoutPageInput>;
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface ConsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  prosAndCons?: Maybe<ProsAndConsWhereInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<ConsWhereInput[] | ConsWhereInput>;
  OR?: Maybe<ConsWhereInput[] | ConsWhereInput>;
  NOT?: Maybe<ConsWhereInput[] | ConsWhereInput>;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface AlertBoxSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AlertBoxWhereInput>;
  AND?: Maybe<
    AlertBoxSubscriptionWhereInput[] | AlertBoxSubscriptionWhereInput
  >;
  OR?: Maybe<AlertBoxSubscriptionWhereInput[] | AlertBoxSubscriptionWhereInput>;
  NOT?: Maybe<
    AlertBoxSubscriptionWhereInput[] | AlertBoxSubscriptionWhereInput
  >;
}

export interface UserUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
}

export interface PageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  type?: Maybe<PageType>;
  type_not?: Maybe<PageType>;
  type_in?: Maybe<PageType[] | PageType>;
  type_not_in?: Maybe<PageType[] | PageType>;
  status?: Maybe<PageStatus>;
  status_not?: Maybe<PageStatus>;
  status_in?: Maybe<PageStatus[] | PageStatus>;
  status_not_in?: Maybe<PageStatus[] | PageStatus>;
  vertical?: Maybe<String>;
  vertical_not?: Maybe<String>;
  vertical_in?: Maybe<String[] | String>;
  vertical_not_in?: Maybe<String[] | String>;
  vertical_lt?: Maybe<String>;
  vertical_lte?: Maybe<String>;
  vertical_gt?: Maybe<String>;
  vertical_gte?: Maybe<String>;
  vertical_contains?: Maybe<String>;
  vertical_not_contains?: Maybe<String>;
  vertical_starts_with?: Maybe<String>;
  vertical_not_starts_with?: Maybe<String>;
  vertical_ends_with?: Maybe<String>;
  vertical_not_ends_with?: Maybe<String>;
  media?: Maybe<MediaWhereInput>;
  blocks_every?: Maybe<BlockWhereInput>;
  blocks_some?: Maybe<BlockWhereInput>;
  blocks_none?: Maybe<BlockWhereInput>;
  boxes_every?: Maybe<BoxWhereInput>;
  boxes_some?: Maybe<BoxWhereInput>;
  boxes_none?: Maybe<BoxWhereInput>;
  prosAndCons_every?: Maybe<ProsAndConsWhereInput>;
  prosAndCons_some?: Maybe<ProsAndConsWhereInput>;
  prosAndCons_none?: Maybe<ProsAndConsWhereInput>;
  alertBoxes_every?: Maybe<AlertBoxWhereInput>;
  alertBoxes_some?: Maybe<AlertBoxWhereInput>;
  alertBoxes_none?: Maybe<AlertBoxWhereInput>;
  quickTips_every?: Maybe<QuickTipWhereInput>;
  quickTips_some?: Maybe<QuickTipWhereInput>;
  quickTips_none?: Maybe<QuickTipWhereInput>;
  AND?: Maybe<PageWhereInput[] | PageWhereInput>;
  OR?: Maybe<PageWhereInput[] | PageWhereInput>;
  NOT?: Maybe<PageWhereInput[] | PageWhereInput>;
}

export interface UserUpdatepermissionsInput {
  set?: Maybe<Permission[] | Permission>;
}

export interface ProsCreateInput {
  id?: Maybe<ID_Input>;
  prosAndCons: ProsAndConsCreateOneWithoutProsInput;
  content?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export type QuickTipWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface BoxCreateManyWithoutPageInput {
  create?: Maybe<BoxCreateWithoutPageInput[] | BoxCreateWithoutPageInput>;
  connect?: Maybe<BoxWhereUniqueInput[] | BoxWhereUniqueInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface BlockUpdateManyWithoutPageInput {
  create?: Maybe<BlockCreateWithoutPageInput[] | BlockCreateWithoutPageInput>;
  delete?: Maybe<BlockWhereUniqueInput[] | BlockWhereUniqueInput>;
  connect?: Maybe<BlockWhereUniqueInput[] | BlockWhereUniqueInput>;
  set?: Maybe<BlockWhereUniqueInput[] | BlockWhereUniqueInput>;
  disconnect?: Maybe<BlockWhereUniqueInput[] | BlockWhereUniqueInput>;
  update?: Maybe<
    | BlockUpdateWithWhereUniqueWithoutPageInput[]
    | BlockUpdateWithWhereUniqueWithoutPageInput
  >;
  upsert?: Maybe<
    | BlockUpsertWithWhereUniqueWithoutPageInput[]
    | BlockUpsertWithWhereUniqueWithoutPageInput
  >;
  deleteMany?: Maybe<BlockScalarWhereInput[] | BlockScalarWhereInput>;
  updateMany?: Maybe<
    BlockUpdateManyWithWhereNestedInput[] | BlockUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateManyDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
}

export interface PageUpdateOneRequiredWithoutQuickTipsInput {
  create?: Maybe<PageCreateWithoutQuickTipsInput>;
  update?: Maybe<PageUpdateWithoutQuickTipsDataInput>;
  upsert?: Maybe<PageUpsertWithoutQuickTipsInput>;
  connect?: Maybe<PageWhereUniqueInput>;
}

export type ProsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FaqCategoryUpsertWithWhereUniqueWithoutFaqsInput {
  where: FaqCategoryWhereUniqueInput;
  update: FaqCategoryUpdateWithoutFaqsDataInput;
  create: FaqCategoryCreateWithoutFaqsInput;
}

export interface FaqCategoryUpdateWithoutFaqsDataInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  description?: Maybe<String>;
}

export interface FaqCategoryUpdateWithWhereUniqueWithoutFaqsInput {
  where: FaqCategoryWhereUniqueInput;
  data: FaqCategoryUpdateWithoutFaqsDataInput;
}

export interface FaqCategoryUpdateManyWithoutFaqsInput {
  create?: Maybe<
    FaqCategoryCreateWithoutFaqsInput[] | FaqCategoryCreateWithoutFaqsInput
  >;
  delete?: Maybe<FaqCategoryWhereUniqueInput[] | FaqCategoryWhereUniqueInput>;
  connect?: Maybe<FaqCategoryWhereUniqueInput[] | FaqCategoryWhereUniqueInput>;
  set?: Maybe<FaqCategoryWhereUniqueInput[] | FaqCategoryWhereUniqueInput>;
  disconnect?: Maybe<
    FaqCategoryWhereUniqueInput[] | FaqCategoryWhereUniqueInput
  >;
  update?: Maybe<
    | FaqCategoryUpdateWithWhereUniqueWithoutFaqsInput[]
    | FaqCategoryUpdateWithWhereUniqueWithoutFaqsInput
  >;
  upsert?: Maybe<
    | FaqCategoryUpsertWithWhereUniqueWithoutFaqsInput[]
    | FaqCategoryUpsertWithWhereUniqueWithoutFaqsInput
  >;
  deleteMany?: Maybe<
    FaqCategoryScalarWhereInput[] | FaqCategoryScalarWhereInput
  >;
  updateMany?: Maybe<
    | FaqCategoryUpdateManyWithWhereNestedInput[]
    | FaqCategoryUpdateManyWithWhereNestedInput
  >;
}

export interface ProsAndConsUpsertWithoutProsInput {
  update: ProsAndConsUpdateWithoutProsDataInput;
  create: ProsAndConsCreateWithoutProsInput;
}

export interface PageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PageWhereInput>;
  AND?: Maybe<PageSubscriptionWhereInput[] | PageSubscriptionWhereInput>;
  OR?: Maybe<PageSubscriptionWhereInput[] | PageSubscriptionWhereInput>;
  NOT?: Maybe<PageSubscriptionWhereInput[] | PageSubscriptionWhereInput>;
}

export interface QuickTipCreateManyWithoutPageInput {
  create?: Maybe<
    QuickTipCreateWithoutPageInput[] | QuickTipCreateWithoutPageInput
  >;
  connect?: Maybe<QuickTipWhereUniqueInput[] | QuickTipWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BoxEdge {
  node: Box;
  cursor: String;
}

export interface BoxEdgePromise extends Promise<BoxEdge>, Fragmentable {
  node: <T = BoxPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BoxEdgeSubscription
  extends Promise<AsyncIterator<BoxEdge>>,
    Fragmentable {
  node: <T = BoxSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions: Permission[];
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  permissions: () => Promise<Permission[]>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  permissions: () => Promise<AsyncIterator<Permission[]>>;
}

export interface BoxConnection {
  pageInfo: PageInfo;
  edges: BoxEdge[];
}

export interface BoxConnectionPromise
  extends Promise<BoxConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BoxEdge>>() => T;
  aggregate: <T = AggregateBoxPromise>() => T;
}

export interface BoxConnectionSubscription
  extends Promise<AsyncIterator<BoxConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BoxEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBoxSubscription>() => T;
}

export interface Block {
  id: ID_Output;
  title?: String;
  video?: String;
  style?: String;
  content?: String;
  order?: Int;
}

export interface BlockPromise extends Promise<Block>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  video: () => Promise<String>;
  style: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface BlockSubscription
  extends Promise<AsyncIterator<Block>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = PageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  media: <T = MediaSubscription>() => T;
  video: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface BlockNullablePromise
  extends Promise<Block | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  video: () => Promise<String>;
  style: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface AggregateBlock {
  count: Int;
}

export interface AggregateBlockPromise
  extends Promise<AggregateBlock>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlockSubscription
  extends Promise<AsyncIterator<AggregateBlock>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlockEdge {
  node: Block;
  cursor: String;
}

export interface BlockEdgePromise extends Promise<BlockEdge>, Fragmentable {
  node: <T = BlockPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BlockEdgeSubscription
  extends Promise<AsyncIterator<BlockEdge>>,
    Fragmentable {
  node: <T = BlockSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AlertBox {
  id: ID_Output;
  title?: String;
  content?: String;
  prefix?: String;
  style?: String;
  order?: Int;
}

export interface AlertBoxPromise extends Promise<AlertBox>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  content: () => Promise<String>;
  prefix: () => Promise<String>;
  style: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface AlertBoxSubscription
  extends Promise<AsyncIterator<AlertBox>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = PageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  prefix: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface AlertBoxNullablePromise
  extends Promise<AlertBox | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  content: () => Promise<String>;
  prefix: () => Promise<String>;
  style: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface QuickTipEdge {
  node: QuickTip;
  cursor: String;
}

export interface QuickTipEdgePromise
  extends Promise<QuickTipEdge>,
    Fragmentable {
  node: <T = QuickTipPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuickTipEdgeSubscription
  extends Promise<AsyncIterator<QuickTipEdge>>,
    Fragmentable {
  node: <T = QuickTipSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AlertBoxSubscriptionPayload {
  mutation: MutationType;
  node: AlertBox;
  updatedFields: String[];
  previousValues: AlertBoxPreviousValues;
}

export interface AlertBoxSubscriptionPayloadPromise
  extends Promise<AlertBoxSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AlertBoxPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AlertBoxPreviousValuesPromise>() => T;
}

export interface AlertBoxSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AlertBoxSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AlertBoxSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AlertBoxPreviousValuesSubscription>() => T;
}

export interface AggregateProsAndCons {
  count: Int;
}

export interface AggregateProsAndConsPromise
  extends Promise<AggregateProsAndCons>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProsAndConsSubscription
  extends Promise<AsyncIterator<AggregateProsAndCons>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AlertBoxPreviousValues {
  id: ID_Output;
  title?: String;
  content?: String;
  prefix?: String;
  style?: String;
  order?: Int;
}

export interface AlertBoxPreviousValuesPromise
  extends Promise<AlertBoxPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  prefix: () => Promise<String>;
  style: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface AlertBoxPreviousValuesSubscription
  extends Promise<AsyncIterator<AlertBoxPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  prefix: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface ProsAndConsConnection {
  pageInfo: PageInfo;
  edges: ProsAndConsEdge[];
}

export interface ProsAndConsConnectionPromise
  extends Promise<ProsAndConsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProsAndConsEdge>>() => T;
  aggregate: <T = AggregateProsAndConsPromise>() => T;
}

export interface ProsAndConsConnectionSubscription
  extends Promise<AsyncIterator<ProsAndConsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProsAndConsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProsAndConsSubscription>() => T;
}

export interface BlockConnection {
  pageInfo: PageInfo;
  edges: BlockEdge[];
}

export interface BlockConnectionPromise
  extends Promise<BlockConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlockEdge>>() => T;
  aggregate: <T = AggregateBlockPromise>() => T;
}

export interface BlockConnectionSubscription
  extends Promise<AsyncIterator<BlockConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlockEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlockSubscription>() => T;
}

export interface ProsEdge {
  node: Pros;
  cursor: String;
}

export interface ProsEdgePromise extends Promise<ProsEdge>, Fragmentable {
  node: <T = ProsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProsEdgeSubscription
  extends Promise<AsyncIterator<ProsEdge>>,
    Fragmentable {
  node: <T = ProsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BlockSubscriptionPayload {
  mutation: MutationType;
  node: Block;
  updatedFields: String[];
  previousValues: BlockPreviousValues;
}

export interface BlockSubscriptionPayloadPromise
  extends Promise<BlockSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlockPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BlockPreviousValuesPromise>() => T;
}

export interface BlockSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlockSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlockSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BlockPreviousValuesSubscription>() => T;
}

export interface AggregatePage {
  count: Int;
}

export interface AggregatePagePromise
  extends Promise<AggregatePage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePageSubscription
  extends Promise<AsyncIterator<AggregatePage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlockPreviousValues {
  id: ID_Output;
  title?: String;
  video?: String;
  style?: String;
  content?: String;
  order?: Int;
}

export interface BlockPreviousValuesPromise
  extends Promise<BlockPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  video: () => Promise<String>;
  style: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface BlockPreviousValuesSubscription
  extends Promise<AsyncIterator<BlockPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  video: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface PageConnection {
  pageInfo: PageInfo;
  edges: PageEdge[];
}

export interface PageConnectionPromise
  extends Promise<PageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PageEdge>>() => T;
  aggregate: <T = AggregatePagePromise>() => T;
}

export interface PageConnectionSubscription
  extends Promise<AsyncIterator<PageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PageEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePageSubscription>() => T;
}

export interface AggregateAlertBox {
  count: Int;
}

export interface AggregateAlertBoxPromise
  extends Promise<AggregateAlertBox>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAlertBoxSubscription
  extends Promise<AsyncIterator<AggregateAlertBox>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateMedia {
  count: Int;
}

export interface AggregateMediaPromise
  extends Promise<AggregateMedia>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMediaSubscription
  extends Promise<AsyncIterator<AggregateMedia>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BoxSubscriptionPayload {
  mutation: MutationType;
  node: Box;
  updatedFields: String[];
  previousValues: BoxPreviousValues;
}

export interface BoxSubscriptionPayloadPromise
  extends Promise<BoxSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BoxPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BoxPreviousValuesPromise>() => T;
}

export interface BoxSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BoxSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BoxSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BoxPreviousValuesSubscription>() => T;
}

export interface MediaConnection {
  pageInfo: PageInfo;
  edges: MediaEdge[];
}

export interface MediaConnectionPromise
  extends Promise<MediaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MediaEdge>>() => T;
  aggregate: <T = AggregateMediaPromise>() => T;
}

export interface MediaConnectionSubscription
  extends Promise<AsyncIterator<MediaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MediaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMediaSubscription>() => T;
}

export interface BoxPreviousValues {
  id: ID_Output;
  title?: String;
  video?: String;
  style?: String;
  content?: String;
  order?: Int;
}

export interface BoxPreviousValuesPromise
  extends Promise<BoxPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  video: () => Promise<String>;
  style: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface BoxPreviousValuesSubscription
  extends Promise<AsyncIterator<BoxPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  video: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateFaqCategory {
  count: Int;
}

export interface AggregateFaqCategoryPromise
  extends Promise<AggregateFaqCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFaqCategorySubscription
  extends Promise<AsyncIterator<AggregateFaqCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AlertBoxEdge {
  node: AlertBox;
  cursor: String;
}

export interface AlertBoxEdgePromise
  extends Promise<AlertBoxEdge>,
    Fragmentable {
  node: <T = AlertBoxPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AlertBoxEdgeSubscription
  extends Promise<AsyncIterator<AlertBoxEdge>>,
    Fragmentable {
  node: <T = AlertBoxSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FaqCategoryConnection {
  pageInfo: PageInfo;
  edges: FaqCategoryEdge[];
}

export interface FaqCategoryConnectionPromise
  extends Promise<FaqCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FaqCategoryEdge>>() => T;
  aggregate: <T = AggregateFaqCategoryPromise>() => T;
}

export interface FaqCategoryConnectionSubscription
  extends Promise<AsyncIterator<FaqCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FaqCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFaqCategorySubscription>() => T;
}

export interface ConsSubscriptionPayload {
  mutation: MutationType;
  node: Cons;
  updatedFields: String[];
  previousValues: ConsPreviousValues;
}

export interface ConsSubscriptionPayloadPromise
  extends Promise<ConsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConsPreviousValuesPromise>() => T;
}

export interface ConsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ConsPreviousValuesSubscription>() => T;
}

export interface FaqEdge {
  node: Faq;
  cursor: String;
}

export interface FaqEdgePromise extends Promise<FaqEdge>, Fragmentable {
  node: <T = FaqPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FaqEdgeSubscription
  extends Promise<AsyncIterator<FaqEdge>>,
    Fragmentable {
  node: <T = FaqSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ConsPreviousValues {
  id: ID_Output;
  content?: String;
  order?: Int;
}

export interface ConsPreviousValuesPromise
  extends Promise<ConsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface ConsPreviousValuesSubscription
  extends Promise<AsyncIterator<ConsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface Media {
  id: ID_Output;
  url: String;
  title?: String;
  altText?: String;
}

export interface MediaPromise extends Promise<Media>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  altText: () => Promise<String>;
}

export interface MediaSubscription
  extends Promise<AsyncIterator<Media>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  altText: () => Promise<AsyncIterator<String>>;
}

export interface MediaNullablePromise
  extends Promise<Media | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  altText: () => Promise<String>;
}

export interface FaqConnection {
  pageInfo: PageInfo;
  edges: FaqEdge[];
}

export interface FaqConnectionPromise
  extends Promise<FaqConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FaqEdge>>() => T;
  aggregate: <T = AggregateFaqPromise>() => T;
}

export interface FaqConnectionSubscription
  extends Promise<AsyncIterator<FaqConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FaqEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFaqSubscription>() => T;
}

export interface Pros {
  id: ID_Output;
  content?: String;
  order?: Int;
}

export interface ProsPromise extends Promise<Pros>, Fragmentable {
  id: () => Promise<ID_Output>;
  prosAndCons: <T = ProsAndConsPromise>() => T;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface ProsSubscription
  extends Promise<AsyncIterator<Pros>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  prosAndCons: <T = ProsAndConsSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface ProsNullablePromise
  extends Promise<Pros | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  prosAndCons: <T = ProsAndConsPromise>() => T;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface FaqCategory {
  id: ID_Output;
  name: String;
  slug: String;
  description: String;
}

export interface FaqCategoryPromise extends Promise<FaqCategory>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  description: () => Promise<String>;
  faqs: <T = FragmentableArray<Faq>>(args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FaqCategorySubscription
  extends Promise<AsyncIterator<FaqCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  faqs: <T = Promise<AsyncIterator<FaqSubscription>>>(args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FaqCategoryNullablePromise
  extends Promise<FaqCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  description: () => Promise<String>;
  faqs: <T = FragmentableArray<Faq>>(args?: {
    where?: FaqWhereInput;
    orderBy?: FaqOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Faq {
  id: ID_Output;
  title: String;
  description?: String;
  short_description?: String;
  slug: String;
  vertical?: String;
  readingTime?: Int;
  order?: Int;
  variant: String[];
  tag: String[];
  pubDate?: DateTimeOutput;
}

export interface FaqPromise extends Promise<Faq>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  short_description: () => Promise<String>;
  authors: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  slug: () => Promise<String>;
  vertical: () => Promise<String>;
  category: <T = FragmentableArray<FaqCategory>>(args?: {
    where?: FaqCategoryWhereInput;
    orderBy?: FaqCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  readingTime: () => Promise<Int>;
  order: () => Promise<Int>;
  variant: () => Promise<String[]>;
  tag: () => Promise<String[]>;
  pubDate: () => Promise<DateTimeOutput>;
}

export interface FaqSubscription
  extends Promise<AsyncIterator<Faq>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  short_description: () => Promise<AsyncIterator<String>>;
  authors: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  slug: () => Promise<AsyncIterator<String>>;
  vertical: () => Promise<AsyncIterator<String>>;
  category: <T = Promise<AsyncIterator<FaqCategorySubscription>>>(args?: {
    where?: FaqCategoryWhereInput;
    orderBy?: FaqCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  readingTime: () => Promise<AsyncIterator<Int>>;
  order: () => Promise<AsyncIterator<Int>>;
  variant: () => Promise<AsyncIterator<String[]>>;
  tag: () => Promise<AsyncIterator<String[]>>;
  pubDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FaqNullablePromise extends Promise<Faq | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  short_description: () => Promise<String>;
  authors: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  slug: () => Promise<String>;
  vertical: () => Promise<String>;
  category: <T = FragmentableArray<FaqCategory>>(args?: {
    where?: FaqCategoryWhereInput;
    orderBy?: FaqCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  readingTime: () => Promise<Int>;
  order: () => Promise<Int>;
  variant: () => Promise<String[]>;
  tag: () => Promise<String[]>;
  pubDate: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions: Permission[];
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  permissions: () => Promise<Permission[]>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  permissions: () => Promise<AsyncIterator<Permission[]>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  permissions: () => Promise<Permission[]>;
}

export interface ConsEdge {
  node: Cons;
  cursor: String;
}

export interface ConsEdgePromise extends Promise<ConsEdge>, Fragmentable {
  node: <T = ConsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConsEdgeSubscription
  extends Promise<AsyncIterator<ConsEdge>>,
    Fragmentable {
  node: <T = ConsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FaqSubscriptionPayload {
  mutation: MutationType;
  node: Faq;
  updatedFields: String[];
  previousValues: FaqPreviousValues;
}

export interface FaqSubscriptionPayloadPromise
  extends Promise<FaqSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FaqPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FaqPreviousValuesPromise>() => T;
}

export interface FaqSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FaqSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FaqSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FaqPreviousValuesSubscription>() => T;
}

export interface AggregateBox {
  count: Int;
}

export interface AggregateBoxPromise
  extends Promise<AggregateBox>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBoxSubscription
  extends Promise<AsyncIterator<AggregateBox>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FaqPreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
  short_description?: String;
  slug: String;
  vertical?: String;
  readingTime?: Int;
  order?: Int;
  variant: String[];
  tag: String[];
  pubDate?: DateTimeOutput;
}

export interface FaqPreviousValuesPromise
  extends Promise<FaqPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  short_description: () => Promise<String>;
  slug: () => Promise<String>;
  vertical: () => Promise<String>;
  readingTime: () => Promise<Int>;
  order: () => Promise<Int>;
  variant: () => Promise<String[]>;
  tag: () => Promise<String[]>;
  pubDate: () => Promise<DateTimeOutput>;
}

export interface FaqPreviousValuesSubscription
  extends Promise<AsyncIterator<FaqPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  short_description: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  vertical: () => Promise<AsyncIterator<String>>;
  readingTime: () => Promise<AsyncIterator<Int>>;
  order: () => Promise<AsyncIterator<Int>>;
  variant: () => Promise<AsyncIterator<String[]>>;
  tag: () => Promise<AsyncIterator<String[]>>;
  pubDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProsAndCons {
  id: ID_Output;
  title?: String;
  order?: Int;
}

export interface ProsAndConsPromise extends Promise<ProsAndCons>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  order: () => Promise<Int>;
  pros: <T = FragmentableArray<Pros>>(args?: {
    where?: ProsWhereInput;
    orderBy?: ProsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cons: <T = FragmentableArray<Cons>>(args?: {
    where?: ConsWhereInput;
    orderBy?: ConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProsAndConsSubscription
  extends Promise<AsyncIterator<ProsAndCons>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = PageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  pros: <T = Promise<AsyncIterator<ProsSubscription>>>(args?: {
    where?: ProsWhereInput;
    orderBy?: ProsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cons: <T = Promise<AsyncIterator<ConsSubscription>>>(args?: {
    where?: ConsWhereInput;
    orderBy?: ConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProsAndConsNullablePromise
  extends Promise<ProsAndCons | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  order: () => Promise<Int>;
  pros: <T = FragmentableArray<Pros>>(args?: {
    where?: ProsWhereInput;
    orderBy?: ProsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cons: <T = FragmentableArray<Cons>>(args?: {
    where?: ConsWhereInput;
    orderBy?: ConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuickTip {
  count: Int;
}

export interface AggregateQuickTipPromise
  extends Promise<AggregateQuickTip>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuickTipSubscription
  extends Promise<AsyncIterator<AggregateQuickTip>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FaqCategorySubscriptionPayload {
  mutation: MutationType;
  node: FaqCategory;
  updatedFields: String[];
  previousValues: FaqCategoryPreviousValues;
}

export interface FaqCategorySubscriptionPayloadPromise
  extends Promise<FaqCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FaqCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FaqCategoryPreviousValuesPromise>() => T;
}

export interface FaqCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FaqCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FaqCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FaqCategoryPreviousValuesSubscription>() => T;
}

export interface ProsAndConsEdge {
  node: ProsAndCons;
  cursor: String;
}

export interface ProsAndConsEdgePromise
  extends Promise<ProsAndConsEdge>,
    Fragmentable {
  node: <T = ProsAndConsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProsAndConsEdgeSubscription
  extends Promise<AsyncIterator<ProsAndConsEdge>>,
    Fragmentable {
  node: <T = ProsAndConsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FaqCategoryPreviousValues {
  id: ID_Output;
  name: String;
  slug: String;
  description: String;
}

export interface FaqCategoryPreviousValuesPromise
  extends Promise<FaqCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  description: () => Promise<String>;
}

export interface FaqCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<FaqCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ProsConnection {
  pageInfo: PageInfo;
  edges: ProsEdge[];
}

export interface ProsConnectionPromise
  extends Promise<ProsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProsEdge>>() => T;
  aggregate: <T = AggregateProsPromise>() => T;
}

export interface ProsConnectionSubscription
  extends Promise<AsyncIterator<ProsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProsSubscription>() => T;
}

export interface AlertBoxConnection {
  pageInfo: PageInfo;
  edges: AlertBoxEdge[];
}

export interface AlertBoxConnectionPromise
  extends Promise<AlertBoxConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AlertBoxEdge>>() => T;
  aggregate: <T = AggregateAlertBoxPromise>() => T;
}

export interface AlertBoxConnectionSubscription
  extends Promise<AsyncIterator<AlertBoxConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AlertBoxEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAlertBoxSubscription>() => T;
}

export interface Page {
  id: ID_Output;
  title: String;
  slug: String;
  type: PageType;
  status: PageStatus;
  vertical?: String;
}

export interface PagePromise extends Promise<Page>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  slug: () => Promise<String>;
  type: () => Promise<PageType>;
  status: () => Promise<PageStatus>;
  vertical: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  blocks: <T = FragmentableArray<Block>>(args?: {
    where?: BlockWhereInput;
    orderBy?: BlockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boxes: <T = FragmentableArray<Box>>(args?: {
    where?: BoxWhereInput;
    orderBy?: BoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  prosAndCons: <T = FragmentableArray<ProsAndCons>>(args?: {
    where?: ProsAndConsWhereInput;
    orderBy?: ProsAndConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  alertBoxes: <T = FragmentableArray<AlertBox>>(args?: {
    where?: AlertBoxWhereInput;
    orderBy?: AlertBoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quickTips: <T = FragmentableArray<QuickTip>>(args?: {
    where?: QuickTipWhereInput;
    orderBy?: QuickTipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PageSubscription
  extends Promise<AsyncIterator<Page>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<PageType>>;
  status: () => Promise<AsyncIterator<PageStatus>>;
  vertical: () => Promise<AsyncIterator<String>>;
  media: <T = MediaSubscription>() => T;
  blocks: <T = Promise<AsyncIterator<BlockSubscription>>>(args?: {
    where?: BlockWhereInput;
    orderBy?: BlockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boxes: <T = Promise<AsyncIterator<BoxSubscription>>>(args?: {
    where?: BoxWhereInput;
    orderBy?: BoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  prosAndCons: <T = Promise<AsyncIterator<ProsAndConsSubscription>>>(args?: {
    where?: ProsAndConsWhereInput;
    orderBy?: ProsAndConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  alertBoxes: <T = Promise<AsyncIterator<AlertBoxSubscription>>>(args?: {
    where?: AlertBoxWhereInput;
    orderBy?: AlertBoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quickTips: <T = Promise<AsyncIterator<QuickTipSubscription>>>(args?: {
    where?: QuickTipWhereInput;
    orderBy?: QuickTipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PageNullablePromise
  extends Promise<Page | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  slug: () => Promise<String>;
  type: () => Promise<PageType>;
  status: () => Promise<PageStatus>;
  vertical: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  blocks: <T = FragmentableArray<Block>>(args?: {
    where?: BlockWhereInput;
    orderBy?: BlockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  boxes: <T = FragmentableArray<Box>>(args?: {
    where?: BoxWhereInput;
    orderBy?: BoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  prosAndCons: <T = FragmentableArray<ProsAndCons>>(args?: {
    where?: ProsAndConsWhereInput;
    orderBy?: ProsAndConsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  alertBoxes: <T = FragmentableArray<AlertBox>>(args?: {
    where?: AlertBoxWhereInput;
    orderBy?: AlertBoxOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quickTips: <T = FragmentableArray<QuickTip>>(args?: {
    where?: QuickTipWhereInput;
    orderBy?: QuickTipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MediaSubscriptionPayload {
  mutation: MutationType;
  node: Media;
  updatedFields: String[];
  previousValues: MediaPreviousValues;
}

export interface MediaSubscriptionPayloadPromise
  extends Promise<MediaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MediaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MediaPreviousValuesPromise>() => T;
}

export interface MediaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MediaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MediaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MediaPreviousValuesSubscription>() => T;
}

export interface QuickTipPreviousValues {
  id: ID_Output;
  title?: String;
  content?: String;
  buttonText?: String;
  buttonLink?: String;
  order?: Int;
}

export interface QuickTipPreviousValuesPromise
  extends Promise<QuickTipPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  buttonText: () => Promise<String>;
  buttonLink: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface QuickTipPreviousValuesSubscription
  extends Promise<AsyncIterator<QuickTipPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  buttonText: () => Promise<AsyncIterator<String>>;
  buttonLink: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface MediaPreviousValues {
  id: ID_Output;
  url: String;
  title?: String;
  altText?: String;
}

export interface MediaPreviousValuesPromise
  extends Promise<MediaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  altText: () => Promise<String>;
}

export interface MediaPreviousValuesSubscription
  extends Promise<AsyncIterator<MediaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  altText: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFaq {
  count: Int;
}

export interface AggregateFaqPromise
  extends Promise<AggregateFaq>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFaqSubscription
  extends Promise<AsyncIterator<AggregateFaq>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuickTip {
  id: ID_Output;
  title?: String;
  content?: String;
  buttonText?: String;
  buttonLink?: String;
  order?: Int;
}

export interface QuickTipPromise extends Promise<QuickTip>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  content: () => Promise<String>;
  buttonText: () => Promise<String>;
  buttonLink: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  order: () => Promise<Int>;
}

export interface QuickTipSubscription
  extends Promise<AsyncIterator<QuickTip>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = PageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  buttonText: () => Promise<AsyncIterator<String>>;
  buttonLink: () => Promise<AsyncIterator<String>>;
  media: <T = MediaSubscription>() => T;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface QuickTipNullablePromise
  extends Promise<QuickTip | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  content: () => Promise<String>;
  buttonText: () => Promise<String>;
  buttonLink: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  order: () => Promise<Int>;
}

export interface AggregateCons {
  count: Int;
}

export interface AggregateConsPromise
  extends Promise<AggregateCons>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConsSubscription
  extends Promise<AsyncIterator<AggregateCons>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageSubscriptionPayload {
  mutation: MutationType;
  node: Page;
  updatedFields: String[];
  previousValues: PagePreviousValues;
}

export interface PageSubscriptionPayloadPromise
  extends Promise<PageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PagePreviousValuesPromise>() => T;
}

export interface PageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PagePreviousValuesSubscription>() => T;
}

export interface Box {
  id: ID_Output;
  title?: String;
  video?: String;
  style?: String;
  content?: String;
  order?: Int;
}

export interface BoxPromise extends Promise<Box>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  video: () => Promise<String>;
  style: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface BoxSubscription
  extends Promise<AsyncIterator<Box>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: <T = PageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  media: <T = MediaSubscription>() => T;
  video: () => Promise<AsyncIterator<String>>;
  style: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface BoxNullablePromise extends Promise<Box | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: <T = PagePromise>() => T;
  title: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  video: () => Promise<String>;
  style: () => Promise<String>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface PagePreviousValues {
  id: ID_Output;
  title: String;
  slug: String;
  type: PageType;
  status: PageStatus;
  vertical?: String;
}

export interface PagePreviousValuesPromise
  extends Promise<PagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  slug: () => Promise<String>;
  type: () => Promise<PageType>;
  status: () => Promise<PageStatus>;
  vertical: () => Promise<String>;
}

export interface PagePreviousValuesSubscription
  extends Promise<AsyncIterator<PagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<PageType>>;
  status: () => Promise<AsyncIterator<PageStatus>>;
  vertical: () => Promise<AsyncIterator<String>>;
}

export interface QuickTipConnection {
  pageInfo: PageInfo;
  edges: QuickTipEdge[];
}

export interface QuickTipConnectionPromise
  extends Promise<QuickTipConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuickTipEdge>>() => T;
  aggregate: <T = AggregateQuickTipPromise>() => T;
}

export interface QuickTipConnectionSubscription
  extends Promise<AsyncIterator<QuickTipConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuickTipEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuickTipSubscription>() => T;
}

export interface QuickTipSubscriptionPayload {
  mutation: MutationType;
  node: QuickTip;
  updatedFields: String[];
  previousValues: QuickTipPreviousValues;
}

export interface QuickTipSubscriptionPayloadPromise
  extends Promise<QuickTipSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuickTipPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuickTipPreviousValuesPromise>() => T;
}

export interface QuickTipSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuickTipSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuickTipSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuickTipPreviousValuesSubscription>() => T;
}

export interface PageEdge {
  node: Page;
  cursor: String;
}

export interface PageEdgePromise extends Promise<PageEdge>, Fragmentable {
  node: <T = PagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PageEdgeSubscription
  extends Promise<AsyncIterator<PageEdge>>,
    Fragmentable {
  node: <T = PageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProsSubscriptionPayload {
  mutation: MutationType;
  node: Pros;
  updatedFields: String[];
  previousValues: ProsPreviousValues;
}

export interface ProsSubscriptionPayloadPromise
  extends Promise<ProsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProsPreviousValuesPromise>() => T;
}

export interface ProsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProsPreviousValuesSubscription>() => T;
}

export interface FaqCategoryEdge {
  node: FaqCategory;
  cursor: String;
}

export interface FaqCategoryEdgePromise
  extends Promise<FaqCategoryEdge>,
    Fragmentable {
  node: <T = FaqCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FaqCategoryEdgeSubscription
  extends Promise<AsyncIterator<FaqCategoryEdge>>,
    Fragmentable {
  node: <T = FaqCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProsAndConsPreviousValues {
  id: ID_Output;
  title?: String;
  order?: Int;
}

export interface ProsAndConsPreviousValuesPromise
  extends Promise<ProsAndConsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface ProsAndConsPreviousValuesSubscription
  extends Promise<AsyncIterator<ProsAndConsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface ProsAndConsSubscriptionPayload {
  mutation: MutationType;
  node: ProsAndCons;
  updatedFields: String[];
  previousValues: ProsAndConsPreviousValues;
}

export interface ProsAndConsSubscriptionPayloadPromise
  extends Promise<ProsAndConsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProsAndConsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProsAndConsPreviousValuesPromise>() => T;
}

export interface ProsAndConsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProsAndConsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProsAndConsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProsAndConsPreviousValuesSubscription>() => T;
}

export interface Cons {
  id: ID_Output;
  content?: String;
  order?: Int;
}

export interface ConsPromise extends Promise<Cons>, Fragmentable {
  id: () => Promise<ID_Output>;
  prosAndCons: <T = ProsAndConsPromise>() => T;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface ConsSubscription
  extends Promise<AsyncIterator<Cons>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  prosAndCons: <T = ProsAndConsSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface ConsNullablePromise
  extends Promise<Cons | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  prosAndCons: <T = ProsAndConsPromise>() => T;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface ProsPreviousValues {
  id: ID_Output;
  content?: String;
  order?: Int;
}

export interface ProsPreviousValuesPromise
  extends Promise<ProsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface ProsPreviousValuesSubscription
  extends Promise<AsyncIterator<ProsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface MediaEdge {
  node: Media;
  cursor: String;
}

export interface MediaEdgePromise extends Promise<MediaEdge>, Fragmentable {
  node: <T = MediaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MediaEdgeSubscription
  extends Promise<AsyncIterator<MediaEdge>>,
    Fragmentable {
  node: <T = MediaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePros {
  count: Int;
}

export interface AggregateProsPromise
  extends Promise<AggregatePros>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProsSubscription
  extends Promise<AsyncIterator<AggregatePros>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ConsConnection {
  pageInfo: PageInfo;
  edges: ConsEdge[];
}

export interface ConsConnectionPromise
  extends Promise<ConsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConsEdge>>() => T;
  aggregate: <T = AggregateConsPromise>() => T;
}

export interface ConsConnectionSubscription
  extends Promise<AsyncIterator<ConsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ConsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateConsSubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "PageType",
    embedded: false
  },
  {
    name: "PageStatus",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Page",
    embedded: false
  },
  {
    name: "Block",
    embedded: false
  },
  {
    name: "Box",
    embedded: false
  },
  {
    name: "AlertBox",
    embedded: false
  },
  {
    name: "QuickTip",
    embedded: false
  },
  {
    name: "ProsAndCons",
    embedded: false
  },
  {
    name: "Pros",
    embedded: false
  },
  {
    name: "Cons",
    embedded: false
  },
  {
    name: "Faq",
    embedded: false
  },
  {
    name: "FaqCategory",
    embedded: false
  },
  {
    name: "Media",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
